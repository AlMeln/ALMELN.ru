### Тест-кейс: понятие и атрибуты

В [учебных программах](/2016-08-14-educational-programs-exam-questions-and-literature.md) по дисциплине "Обеспечение качества и тестирование программ" предусмотрены следующие темы для изучения:
- Тестовый случай, тестовый сценарий и тестовое покрытие.
- Артефакты тестирования. Основные артефакты тестировщика. Тестовая документация. Test Case, Test Specification, Test Plan.
- Правила составления тестов.
- Test Case. Атрибуты и правила составления Test Case.

В программе обучения базового уровня International Software Testing Qualifications Board "Сертифицированный тестировщик" указаны следующие цели изучения методов проектирования тестов:
- Сравнение и понимание терминов тестовое условие, тестовый сценарий и процедура тестирования;
- Оценка качества тестовых сценариев. Понимание могут ли они:
 - Показать четкую трассируемость к требованиям
 - Содержать ожидаемый результат;
- Понимание принципов тестирования по сценариям использования и его выгоды.

Для лучшего понимания темы составил подборку выдержек из стандартов, глоссариев и литературы по тестированию.

### Стандартный глоссарий терминологии по программированию Института инженеров электротехники и электроники

Institute of Electrical and Electronics Engineers Std 610.12-1990, IEEE Standard Glossary of Software Engineering Technology:

Test case. (1) A set of test inputs, execution conditions, and expected results developed for a particular objective, such as to exercise a particular program path or to verify compliance with a specific requirement. (2) (IEEE Std 829-1983 153) Documentation specifying inputs, predicted results, and a set of execution conditions for a test item.

### "Информационная технология. Пакеты программ. Требования к качеству и тестирование"

Государственный стандарт Российской Федерации, Международная организация по стандартизации, Международная электротехническая комиссия №12119-94:

Контрольный пример (test case): Документально оформленное руководство для испытателя, которое определяет, как должна или может быть протестирована функция или комбинация функций. Контрольный пример должен содержать информацию, охватывающую следующие вопросы:

- цель тестирования;
- тестируемые функции;
- среда тестирования и другие условия (уточнение конфигурации средств испытаний и подготовительная работа);
- тестовые данные;
- процедура;
- ожидаемое поведение системы.

### «Тестирование программного обеспечения. Фундаментальные концепции менеджмента бизнес-приложений»

![Канер и Нгуен](https://lh3.googleusercontent.com/OgKs_OSz-vXXxXJVHY7UPQqxqy6I_Nlnpux8oziNep2sSd5Nc3vJZ2sC33dYJFsii0kDg8hNP9rQR5oh4sBPPIA0L3pYiHC7EMYeMKj72KSg_otsMVh2mAaQI85PE4ACCFVeyY_uGKNaqS5IVLz9q7-okh5dqtKfS_L-Kn5REdSroivIBHmuA2MOfhiYqDnwdHoUq23yhcN1wmBBEAs0KiknsyyRDTXmD1jqkMNeNxMoW_rD9YC_W0nZkifDm80WtYsN7vZ1_pxfOMdQAUgh8x28vb5D2x99s52XsnWBXmkYpQOWzSlaQeebyGb8PHgDecji5bY7LJrQyPqJwkWutzNz6szsjY0dFJXkNLk1Ctde9qgi2DOWiJO9-rUWFQmtXEUJtD_XToY_OQipTfCMzl73hoNOm5NXG-dp0eq4JpBxWPc84oyh9xKFqH3dAUB_6dWDWPK95r-rZtU2VHVKrchc-6GYig846bimyrgYDDlHlvhiuyoS9pWh_4qG8wmCayhDmsQD-6te2ag6dy-aH3cDuGOmF9V1q417PD1XIIXNcfKOXubsjuOGWEptwuV0d3xjAsLeeSvNia9oMt8MoOPyZdMPX3nd8j2JOI-hQr7QtdcYNEX30hNnYEK6RT_zlAnwgo5OS0oSHTOeC4uvas0ftzAIoYp1=w700-h394-no)

Сэм Канер, Джек Фолк и Енг Кек Нгуен, Москва, ДиаСофт, 2001. 341-346 страницы:

Кто пользуется тестовой документацией

Главным критерием ценности документа является то, насколько он понятен читателю. Именно на это и ориентируется составитель докумен­та, а потому он должен точно знать, кто его будет читать и какова степень компетентности этого человека. Кроме того, важно, для чего будет исполь­зоваться данный документ — в одних случаях достаточно короткого пояс­нительного описания, а в других требуются четкие и подробные инструкции.

Временные оценки, приведенные в следующих разделах, основаны на опыте нашей собственной работы и, разумеется, очень приблизительны.

**Личные заметки**

Это простейшие из документов. Но все же их следует составлять так, чтобы, прочитав их несколько месяцев спустя, можно было разобраться, о чем идет речь, какие и почему выполнялись тесты и какие результаты были получены. Старайтесь писать их как можно аккуратнее, но при этом будьте кратки. Время, затрачиваемое на заметки о проведенных тестах, должно быть в пределах от половины до троекратного объема времени, необходи­ мого для их разработки и выполнения.

Назначение личных заметок может быть следующим.

- Описание тестов, которые будут проводиться повторно. Вместо того чтобы заново продумывать каждый тест, можно обратиться к заметкам, сделанным на предыдущем этапе работы. В этих заметках могут описываться достаточно сложные подробности. Если речь идет о комплексном тесте с множеством граничных условий и других специфических значений, опишите их все и не забудьте добавить, каково их назначение. Тогда после изменения программы сразу будет ясно, какие изменения нужно будет внести в такой тест.
- Напоминание о том, что уже сделано. Как ни странно, выполнить один и тот же тест десяток раз на протяжении нескольких дней на самом деле ничего не стоит. Иногда тестировщик забывает, что тест уже выполнен, иногда не уверен в этом и на всякий случай выпол­няет его еще раз. Если аккуратно вести журнал проводимых тестов, всей этой путаницы и потерь времени вполне можно избежать.
- Напоминание о том, что еще предстоит сделать. Аккуратно запи­сывайте все идеи о будущем тестировании. В дальнейшем, разраба­ тыва новые тесты, вы можете обращаться к этим записям.
- Ответы на вопросы программистов. Если программисту не удает­ся воспроизвести найденную вами ошибку, он может попросить провести дополнительные тесты, которые, на его взгляд, могут быть связаны с проблемой. Выполнили ли вы эти тесты? В точности ли те, о которых вас просили? Какими были результаты?

**Заметки для другого члена команды**

Речь идет о сотруднике, тестирующем тот же продукт, что и вы. У него могут возникнуть к вам вопросы, или же он может попросить описание одного или нескольких проводимых вами тестов. На составление такого описания может уйти столько времени, сколько необходимо для разработки теста, а даже в 5 раз больше.

В заметках может быть следующая информация.

- Как выполнить каждый тест. Это описание может быть коротким, поскольку предназначается для достаточно опытного сотрудника.
- Ожидаемые результаты каждого теста. Иногда стоит также опи­сать и вероятные условия сбоя.
- Смысл каждого значения данных. Когда программа меняется, а проведенные вами тесты предстоит выполнять другому сотруднику, он может спросить у вас, что следует изменить. И прежде всего ему необходимо будет выяснить назначение данных исходного теста. Во многих случаях вам не придется писать длинных пояснений, по­ скольку назначение данных будет очевидно из ожидаемого резуль­тата.
- Любые другие специальные инструкции, например, как долго следует ждать определенного события или как быстро нажимать клавиши для определенного теста.
- Какие тесты необходимо выполнять регулярно (регрессионные те­сты), какие из них наиболее быстрые и простые и каковы ваши соображения по поводу дальнейшего тестирования.
- Каково назначение данных тестов. Какая часть программы ими исследуется? Какие проблемы могут быть выявлены с наибольшей вероятностью? Если выполняются группы связанных тестов, опиши­ те их с этой точки зрения. В частности, можно описать общее на­значение группы, затем подробно описать один из тестов, а остальные представить как вариации первого. Так и писать будет быстрее, и понять легче.

**Заметки для другого опытного тестировщика**

Разница между этим и предыдущим случаями в том, что на этот раз предполагается, что вас не будет поблизости, чтобы ответить на вопросы. Если, например, вы разрабатываете материалы по контракту, по его завер­шении к вам уже нельзя будет обратиться. Поэтому на описание каждого теста планируйте вдесятеро больше времени, чем на его разработку и вы­ полнение. 

Вам придется предоставить следующие сведения.

- Все, что пишется для члена команды, но в более подробном изло­жении. Особенно аккуратно следует указывать, какой результат оз­начает сбой, а какой — успешное прохождение теста. Если вам кажется, что определенные инструкции сложны для понимания, попросите кого-нибудь выполнить по ним тест и посмотрите, как он справится и что ему будет непонятно. (Особенно часто подобные сложности возникают при описании тестов, связанных с временными параметрами выполнения программы.)
- Дополнительные аналитические материалы, дополнительные опи­сания тестов, их связей, подробные описания групп тестов, а не каждого входящего в них теста по отдельности.
- Зависимости. Если, например, программа может читать максимум 80 байтов данных за один раз, вы будете тестировать ее с 80 и 81 байтом. Если затем возможности программы будут расширены до 256 байтов, старые тесты потеряют смысл. Теперь тестируемые объе­мы данных необходимо будет увеличить до 256 и 257 байтов. В описании этих тестов должно быть явно указано, что они предназ­начены для программы с потолком в 80 байтов. Это замечание луч­ше всего вынести в отдельный раздел под названием "Зависимости" или "Предположения". Тогда вам не придется писать, что делать, если спецификация изменится. Опытный тестировщик прекрасно сообразит это сам — главное, чтобы у него была вся необходимая информация, т.е. чтобы он знал, что с данным параметром програм­мы связаны такие-то и такие-то тесты.

**Заметки для следующего выпуска программы (планируемого, вероятно, через год)**

После выпуска программы работа тестировщиков над ней обычно пре­кращается, чтобы вскоре возобновиться уже над следующим выпуском. При этом вовсе не обязательно, чтобы им занимались те же люди, а потому будущим тестировщикам очень пригодятся любые ваши заметки. Некото­рые из тестовых материалов им, возможно, будет трудно понять. Поэтому подготовьте специальный комплекс записей для облегчения их понимания. Эти записи будут подобны описанным в предыдущем разделе.

Представьте себе будущих тестировщиков как археологов. Им придет­ся прокапываться сквозь ворох вашей документации, всевозможных заме­ток, дисков и т.п. Вполне вероятно, что все, чего они не смогут понять, будет просто отброшено. Или же, что еще хуже, отдельные материалы будут неверно интерпретированы, и в результате будут пропускаться ошибки.
Имейте также в виду, что будущим тестировщикам придется не только выполнять уже готовые тесты, но и модифицировать многие из них, по­ скольку к тому времени программа наверняка изменится.

Итак, вашим последователям будут крайне необходимы следующие материалы.

- Подробности о каждом тесте. Как его выполнить и какие ожида­ются результаты.
- История сбоев программы. Какие проблемы выявлялись каждым из тестов, как они выглядели и какие изменения были внесены в про­грамму для исправления ситуации.
- Дополнительные соображения и проблемные вопросы по поводу каж­дого из тестов, зависимости тестов от поведения программы и спе­цификации.

**Сценарий теста для неопытного тестировщика**
	
Этот человек может быть опытным пользователем компьютера (про­граммистом, руководителем, системотехником), а может быть и совсем новичком. Как бы там ни было, опыта тестирования программных продуктов у него нет и с тестируемой программой он абсолютно незнаком. По­ этому ему необходимо подробное пошаговое руководство — сценарий теста.

Назначение сценариев и обеспечиваемые ими выгоды могут быть сле­дующими.

- Работа по сценариям позволяет сократить размер группы тести­рования. В критической ситуации можно подключить к работе над проектом дополнительный персонал и быстро его обучить. Таким людям необходимо будет просто следовать сценариям — от них не требуется особых знаний и навыков, и их зарплата обычно гораздо меньше, чем у основных специалистов.
- Сценарии освобождают персонал от самой утомительной работы. В двадцатый раз выполняя один и тот же тест, кто угодно будет делать его сонно и невнимательно. Во многих случаях превосходным решением проблемы может быть поручение повторяющихся тестов временным сотрудником.
- Сценарии прекрасно подходят для стандартизированных наборов тестов. Они могут быть основой регрессионного тестирования, однако самые сложные из тестов не следует поручать дилетантам.
- Хороший сценарий производит неотразимое впечатление на руковод­ство. Не следует недооценивать значение этого обстоятельства.

**К сожалению, здесь же имеется и целый ряд проблем**.

- Неопытные тестировщика (включая и многих достаточно опыт­ных программистов) — это плохие тестировщики.

Для подтверждения этого факта приведем пример из нашей соб­ственной практики. Мы исследовали производительность нескольких прекрасных специалистов из отдела технической поддержки. Эти люди занимались жалобами пользователей, уже купивших наш про­дукт. Их заинтересованность в поиске проблем была крайне высо­ка. Работали они по подробным и очень тщательно подготовленным сценариям. Параллельно с ними программу тестировали несколько сотрудников нашей группы — ту же версию и по тем же сценариям. Результат был однозначным: опытные тестировщики нашли больше ошибок, причем среди них были такие, которые вообще было трудно пропустить, и все же неспециалисты их пропустили.

Особенно плохо неопытные тестировщики справляются с трудноуло­вимыми ошибками или ошибками, связанными с временными метрами выполнения программы. Они редко документируют ошибки, которые трудно повторить. Кроме того, они не документи­руют проблемы, которые, как им кажется, могут быть связаны с неверным пониманием программы. Неопытные тестировщики не документируют ошибку, если им кажется, что читатель отчета посчи­тает ее незначительной. И есть еще много других проблем, которые они пропускают или оставляют недокументированными.

- Написание хорошего сценария требует много времени. На написа­ние хорошего сценария и подготовку сопутствующих материалов (копий экрана, файлов и т.п.) уходит в 5-15 раз больше времени, чем на подготовку и выполнение исходного теста.

- Сценарий ни в коем случае не должен содержать ошибок. У тестировщиков, которые им руководствуются, нет ни опыта, ни знаний для исправления ошибок в сценарии. Если что-то пойдет не так, как в нем написано, они просто не будут знать, что делать. И если та­кой тестировщик поймет, что в сценарии есть ошибка, он не будет документировать даже те проблемы, которые увидит, поскольку посчитает, что они связаны со сценарием, а не с самой программой.

Разрабатывая сценарии, следует постоянно иметь в виду, что они пи­шутся не для опытных тестировщиков, а значит, в них должна быть совер­шенно иная информация. Скорее всего, вам придется составлять оба типа документов. В сценарии ничего не говорится о назначении тестов и их входных данных. Ведь неопытного тестировщика такая информация толь­ко смутит. Главное содержание сценария — это процедура выполнения теста, и в частности, следующая информация.

- Четкие пошаговые инструкции для выполнения теста. Его испол­нитель не должен догадываться, что и как делать, это должно быть совершенно четко записано в инструкции.
- Точное описание ожидаемых результатов, включая и то, что должен видеть тестировщик на каждом этапе инструкции. Очень полезны распечатки копий экрана. Отметьте в них маркером, куда именно следует смотреть.
- Описание возможных вариантов неудачного прохождения теста программой. Не вдаваясь во внутренние механизмы работы програм­мы, расскажите, что может быть не так и как это будет выглядеть. Приведите примеры того, что тестировщик может увидеть или услы­шать в случае сбоя.
- Квадратики, в которых тестировщик будет отмечать, что тест выполнен. Сценарий может иметь форму контрольного списка или бланка, в который вписываются ответы на вопросы. Если необходи­мо, чтобы тестировщик обратил внимание на определенный аспект поведения программы, следует внести в сценарий соответствующий вопрос.

То, как организовать сценарий, может существенно повлиять на резуль­таты работы. Инструкции должны быть отделены от описаний, например, "Что сделать" должно быть записано в отдельном столбце, перед "Что вы увидите". Не менее важен и порядок заданий. Тестировщик не должен пе­рескакивать между классами тестов. Кроме того, у него не должно быть чувства, что он зря теряет время. Прежде чем передать сценарий временному персоналу, предложите его для опробования опытному тестировщику.

Типы тестовых документов

**Тестовый сценарий**

Этого документа в стандарте 829 нет. О его назначении и содержании уже рассказывалось в разделе "Сценарий теста для неопытного тестировщика". Вот из чего он состоит.

- Инструкции общего характера. Это пояснения о том, как читать и использовать сценарий, как и когда заполнять отчеты о проблемах, где их найти и т.п. Всю эту информацию можно предоставить тестировщику в виде отдельного документа, чтобы не перегружать сце­нарий, однако в любом случае неопытному тестировщику она абсолютно необходима.
- Начало. В этом разделе приводится описание процесса настройки среды и подготовки к выполнению теста.
- Пошаговые инструкции для выполнения каждого теста.
- Квадратики для отметок о прохождении каждого шага и отметок о результатах.
- ПОЛЯ для описания поведения программы, а также для заметок обо всем непонятном и вопросы, ответами на которые должны служить эти описания. Позднее опытный тестировщик проанализирует эти ответы, самостоятельно проанализирует нестандартное поведение программы и, вероятно, напишет целый ряд новых отчетов о про­блемах.

### «Сертифицированный тестировщик Программа обучения Базового уровня»

![International Software Testing Qualifications Board, Boulevard du Souverain 280, Brussels, Belgium](https://lh3.googleusercontent.com/t6l8d-Gjvf1bf6wYCz88v49fJMc7nWoWBvjfqk-s2yE6P20hy5lyvrVCW32Za5Cq7uBoaAj-WJlDXHeTg6hd3PYPqsCrr1OCss84BjbYtlccue2lcz5ySehIA-GerrlAQ9IUkco822IiVDja3plkbkcwFfD8KAeoMqU3k4jWFDvc_2M_3fSQ2j8nFOo2OTZEUYCeS6sCvU85F53xyEXTNlChYXqlD_a-NfQ856V_ChiyQNi2HBBY2hvvROoO7jes35_lELXfPIHrAKYHix4odeq95SKR7F6CtLUPy3MM_d6vDKYIkeeHcbHpgBGZWlKClZB96_08w8-9Szhgkr4rGXNZ-U3wOijjHvkGqhFvQNx7CjnSsUzR7g5z59yQDDTuIkB_B2gPyg1IQOB0fHIdY1pcjNcdRoAh10AdeVtNpgfs6WmIZNTOgtF2DwHOIHzszVLbIvusodURgVJFh7cqLPCIFqjc8-Y-kEezEZskDGZ0dYhw1NeODDkjawwUi_ctlClQYBqDdL584YQXTQwa8AJ7ZAB7KhmhNLwMDHCcaO7zIP4PCSrNXpohh25RnL9FlfXIjQ6lcYwFZzHHWG-aM7T2Knr-HsmtMEnT607dVzyq6CtRt-tiGPxfwZWm4zdpURk8ZhW-EXbT86emiXS7su_BPDPxiq4c=w780-h514-no)

Версия 2011 (от 13 апреля 2011 года), International Software Testing Qualifications Board, Андрей Конушин (председатель), Александр Александров, Алексей Александров, Татьяна Смехнова, Елена Абрамова. 51-57/101 страница:

4.1 Процесс разработки тестов

Вводная информация

...Тестовый сценарий состоит из набора входных значений, предусловий выполнения, ожидаемых результатов и постусловий, определяемых для покрытия определенных тестовых условий (или тестового условия) или целей (цели) тестирования. Содержание спецификаций проектирования тестов (включая тестовые условия) и спецификаций тестовых сценариев описывается в стандарте «Документация при тестировании программ» (IEEE STD 829-1998).

Ожидаемые результаты должны создаваться как часть спецификаций тестовых сценариев и включать в себя выходные данные, изменения в данных и состояниях, и любые иные последствия теста. Если ожидаемые результаты не были определены, правдоподобные, но ошибочные результаты могут быть приняты за корректные.

В идеальных условиях ожидаемые результаты должны быть определены до момента выполнения теста.

Во время реализации теста тестовые сценарии разрабатываются, реализуются, получают приоритеты и формируют спецификацию процедуры тестирования (IEEE STD 829-1998). Процедура тестирования (или ручной сценарий тестирования) описывает последовательность действий для выполнения теста. Если тесты запускаются с использованием инструмента выполнения тестов, последовательность действий описывается автоматизированным тестовым сценарием...

Рекомендуемая литература для углубления в тему:

1. "Systematic Software Testing", Craig, Rick D. and Jaskiel, Stefan P., 2002;
2. "Complete Guide to Software Testing", Hetzel, W., 1988;
3. IEEE Standard for Software Test Documentation, IEEE Std 829, 1998.

### Стандартный глоссарий терминов, используемых в тестировании программного обеспечения

Версия 2.3 (от 9 июля 2014 года), International Software Testing Qualifications Board, ред. пер. Александр Александров:

Спецификация проектирования теста (test design specification): Документ, описывающий тестовое условие (элементы покрытия) для элемента тестирования, детализованный подход к тестированию, и идентифицирующий соответствующие тестовые сценарии высокого уровня. [IEEE 829] См. также спецификация теста. 

Спецификация процедуры тестирования (test procedure specification): Документ, описывающий последовательность действий при выполнении теста. Также известен как ручной сценарий тестирования. [IEEE 829] См. также спецификация теста.

Спецификация теста (test specification): Документ, состоящий из спецификации проектирования теста, спецификации тестовых сценариев и/или спецификации процедуры тестирования. 

Спецификация тестовых сценариев (test case specification): Документ, описывающий комплект тестовых сценариев - цель, входы, тестовые операции, ожидаемые результаты и предусловия выполнения для объекта тестирования. [IEEE 829] См. также спецификация теста.

Тестовый сценарий (test case): Набор входных значений, предусловий выполнения, ожидаемых результатов и постусловий выполнения, разработанный для определенной цели или тестового условия, таких как выполнения определенного пути программы или же для проверки соответствия определенному требованию. [IEEE 610]

Тестовый сценарий высокого уровня (high level test case): Тестовый сценарий без конкретных (уровня реализации) значений входных данных и ожидаемых результатов. Использует логические операторы, а экземпляры реальных значений еще не определены и/или доступны. См. также тестовый сценарий низкого уровня.

Тестовый сценарий низкого уровня (low level test case): Тестовый сценарий с конкретными (уровня реализации) значениями входных данных и ожидаемых результатов. Логические операторы из тестовых сценариев высокого уровня заменяются реальными значениями, которые соответствуют целям этих логических операторов. См. также тестовые сценарии высокого уровня.

Трассируемость (traceability): Способность идентифицировать связанные объекты в документации и программном обеспечении, например, требования со связанными с ними тестами. См. горизонтальная трассируемость, вертикальная трассируемость.

### "Тестирование программного обеспечения. Базовый курс"

![Святослав Куликов, EPAM](https://lh3.googleusercontent.com/N6l4LtcWxQUMlqQxxBl9xaVmubSyTRk3WZYl88rWmVcQRgJKbe925enFh4zMaa0Fgi7myy_kUosDiOP2yp1sfVMME2hjTgPL2Z7zIwuTFD_VbS08_RRD6cPgB1qDm2xbfkAbpsW3massg0LRJffdImuDolqNvKqckBaJAYIblpY6zqWOigjnYiu-l_VdNIIMb-eZc6iVqbZrzQZ5Qoqr7Er8QURTjYuFmNacP7pOU7Vq60Wse2F9hmN0NQoPBUSLCAIYqW_Ux1RFaERGB5aj1u7HkmlVCQs5u1m0U5QV61VptZQq3h8idbnEs3gtG8c2zU89NX_zkpbHkK2Ws5X5x_v6fxf9-IrYFsaBMsyGaea6v-u2rl9aybLbWcJzlaC8u0MuKtPY1TKf4NnR-mKMduW6ROOn7tLLleiXBhXTBWC8tTkat3b4JcwixGpBx2nMZxfMewUdB9LAJDv0AXng8zKQE2V2WuZ5kVdgoeGaqU-M30F39uCiDir0hAVtzSe6zMhYcGXLH9a6DHIY5OVrSMhptKzHv652cZDHq3MpMlZOQ-w-5-IXsob4YPIoU_79XvOEboxzycRjmGT3TmQUKgggxhihaD1S9tDowYjKQqiEmGYcLmoHLs2vF5e3-7Gv5vhFJRanCPO_yZxzfykfMwkMR2x7vxc3=w1225-h816-no)

Святослав Куликов. Версия книги 1.2.1 от 02.08.2017, EPAM Systems. 114-/295 страницы:

2.4.2. Тест-кейс и его жизненный цикл

Тест-кейс (test case) — набор входных данных, условий выполнения и ожидаемых результатов, разработанный с целью проверки того или иного свойства или поведения программного средства. 

Под тест-кейсом также может пониматься соответствующий документ, представляющий формальную запись тест-кейса.

Мы ещё вернёмся к этой мысли, но уже сейчас критически важно понять и запомнить: если у тест-кейса не указаны входные данные, условия выполнения и ожидаемые результаты, и/или не ясна цель тест-кейса — это плохой тест-кейс (иногда он не имеет смысла, иногда его и вовсе невозможно выполнить).

Примечание: иногда термин «test case» на русский язык переводят как «тестовый случай». Это вполне адекватный перевод, но из-за того, что «тест-кейс» короче произносить, наибольшее распространение получил именно этот вариант.

Высокоуровневый тест-кейс (high level test case287) — тест-кейс без конкретных входных данных и ожидаемых результатов.

Как правило, ограничивается общими идеями и операциями, схож по своей сути с подробно описанным пунктом чек-листа. Достаточно часто встречается в интеграционном тестировании и системном тестировании, а также на уровне дымового тестирования. Может служить отправной точкой для проведения исследовательского тестирования или для создания низкоуровневых тест-кейсов.

Низкоуровневый тест-кейс (low level test case) — тест-кейс с конкретными входными данными и ожидаемыми результатами.  Представляет собой «полностью готовый к выполнению» тест-кейс и вообще является наиболее классическим видом тест-кейсов. Начинающих тестировщиков чаще всего учат писать именно такие тесты, т.к. прописать все данные подробно — намного проще, чем понять, какой информацией можно пренебречь, при этом не снизив ценность тест-кейса.

Спецификация тест-кейса (test case specification) — документ, описывающий набор тест-кейсов (включая их цели, входные данные, условия и шаги выполнения, ожидаемые результаты) для тестируемого элемента (test item, test object).

Спецификация теста (test specification) — документ, состоящий из спецификации тест-дизайна (test design specification), спецификации тест-кейса (test case specification) и/или спецификации тест-процедуры (test procedure specification).

Тест-сценарий (test scenario, test procedure specification, test script) — документ, описывающий последовательность действий по выполнению теста (также известен как «тест-скрипт»).

Внимание! Из-за особенностей перевода очень часто под термином «тест-сценарий» («тестовый сценарий») имеют в виду набор тест-кейсов.

**Цель написания тест-кейсов**

Тестирование можно проводить и без тест-кейсов (не нужно, но можно; да, эффективность такого подхода варьируется в очень широком диапазоне в зависимости от множества факторов). Наличие же тест-кейсов позволяет:

- Структурировать и систематизировать подход к тестированию (без чего крупный проект почти гарантированно обречён на провал).
- Вычислять метрики тестового покрытия (test coverage metrics) и принимать меры по его увеличению (тест-кейсы здесь являются главным источником информации, без которого существование подобных метрик теряет смысл).
- Отслеживать соответствие текущей ситуации плану (сколько примерно понадобится тест-кейсов, сколько уже есть, сколько выполнено из запланированного на данном этапе количества и т.д.).
- Уточнить взаимопонимание между заказчиком, разработчиками и тестировщиками (тест-кейсы зачастую намного более наглядно показывают поведение приложения, чем это отражено в требованиях).
- Хранить информацию для длительного использования и обмена опытом между сотрудниками и командами (или как минимум — не пытаться удержать в голове сотни страниц текста).
- Проводить регрессионное тестирование и повторное тестирование (которые без тест-кейсов было бы вообще невозможно выполнить).
- Повышать качество требований (мы это уже рассматривали: написание чек-листов и тест-кейсов — хорошая техника тестирования требований).
- Быстро вводить в курс дела нового сотрудника, недавно подключившегося к проекту.

**Жизненный цикл тест-кейса**

В отличие от отчёта о дефекте, у которого есть полноценный развитый жизненный цикл, для тест-кейса речь скорее идёт о наборе состояний (см. рисунок 2.4.a), в которых он может находиться (жирным шрифтом отмечены наиболее важные состояния). 

![Рисунок 2.4.a, Святослав Куликов, EPAM, Жизненный цикл (набор состояний) тест-кейса](https://lh3.googleusercontent.com/AQYZnwqYcA6ZRY7B24U7rlvMs1HxAog6yHVVPaqRg9DLUdPTfuJcvVEtIXAE-6LtUImavcM3twNyrBEQ8-UXzkw72-equ5GcEqMUw2agz0VJFCCubXpim5Y3Z-9guj-apdX40C7EMU6cPUK24TiHL1NXiYrn6n0PS6FvZcHJg6WYgD6eY7t2tsgzJ9ZzzJaVBUBH873def983ue2nGERa7gHtj6KEWfc2qnAWbXvr4GPnWQaG-7ra7wIsdfix5h-Obu77kVLVlXdUBQ6nDVpdBxMlhuzfo76g2y09yqOzaQbH-kikGjmsSZcwha8n_HBOi_UocgxZ4fX8Nf4l09e-XsXoJErkPaNicKhYOdfawdfcELBdL_lr-yuLbvv-0J3TBIQPtBZKWy7puBKTjp_9jjuwFTJWVfN0uTPv5TuqrKif8lXkLqEMTKLzbx75byHXPgv74jVN080-_V3GOYHyjG3kg8AqvRnEO5rWcPIIk9okvaVSiy8WvBVaFoyi8MFrGKeSyeX8GH4f7Z2En-dPq94d0Lwqn65GmtaAQfePosgC-s085rZeSallpofovex_EHTAp0q884ZYXfY7ccthEJqAJfJtfdlc3Sr_JLrnacFAIJQoH19Tec11crL-IHYyjthunUnGBLtAwT-e-dR7BMnnadJoMSf=w700-h651-no)

- Создан (new) — типичное начальное состояние практически любого артефакта. Тест-кейс автоматически переходит в это состояние после создания.
- Запланирован (planned, ready for testing) — в этом состоянии тест-кейс находится, когда он или явно включён в план ближайшей итерации тестирования, или как минимум готов для выполнения.
- Не выполнен (not tested) — в некоторых системах управления тест-кейсами это состояние заменяет собой предыдущее («запланирован»). Нахождение тест-кейса в данном состоянии означает, что он готов к выполнению, но ещё не был выполнен.
- Выполняется (work in progress) — если тест-кейс требует длительного времени на выполнение, он может быть переведён в это состояние для подчёркивания того факта, что работа идёт, и скоро можно ожидать её результатов. Если выполнение тест-кейса занимает мало времени, это состояние, как пра-вило, пропускается, а тест-кейс сразу переводится в одно из трёх следующих состояний – «провален», «пройден успешно» или «заблокирован».
- Пропущен (skipped) — бывают ситуации, когда выполнение тест-кейса отменяется по соображениям нехватки времени или изменения логики тестирования.
- Провален (failed) — данное состояние означает, что в процессе выполнения тест-кейса был обнаружен дефект, заключающийся в том, что ожидаемый результат по как минимум одному шагу тест-кейса не совпадает с фактическим результатом. Если в процессе выполнения тест-кейса был «случайно» обнаружен дефект, никак не связанный с шагами тест-кейса и их ожидаемыми результатами, тест-кейс считается пройденным успешно (при этом, естественно, по обнаруженному дефекту создаётся отчёт о дефекте).
- Пройден успешно (passed) — данное состояние означает, что в процессе выполнения тест-кейса не было обнаружено дефектов, связанных с расхождением ожидаемых и фактических результатов его шагов.
- Заблокирован (blocked) — данное состояние означает, что по какой-то причине выполнение тест-кейса невозможно (как правило, такой причиной является наличие дефекта, не позволяющего реализовать некий пользовательский сценарий).
- Закрыт (closed) — очень редкий случай, т.к. тест-кейс, как правило, оставляют в состояниях «провален / пройден успешно / заблокирован / пропущен». В данное состояние в некоторых системах управления тест-кейс переводят, чтобы подчеркнуть тот факт, что на данной итерации тестирования все действия с ним завершены.
- Требует доработки (not ready) — как видно из схемы, в это состояние (и из него) тест-кейс может быть преведён в любой момент времени, если в нём будет обнаружена ошибка, если изменятся требования, по которым он был написан, или наступит иная ситуация, не позволяющая считать тест-кейс пригодным для выполнения и перевода в иные состояния. 

Ещё раз подчеркнём, что в отличие от жизненного цикла дефекта, который достаточно стандартизирован и формализован, для тест-кейса описанное выше носит общий рекомендательный характер, рассматривается скорее как разрозненный набор состояний (а не строгий жизненный цикл) и может сильно отличаться в разных компаниях (в связи с имеющимися традициями и/или возможностями систем управления тест-кейсами).

**2.4.3. Атрибуты (поля) тест-кейса**

Как уже было сказано выше, термин «тест-кейс» может относиться к формальной записи тест-кейса в виде технического документа. Эта запись имеет общепринятую структуру, компоненты которой называются атрибутами (полями) тест-кейса.

В зависимости от инструмента управления тест-кейсами внешний вид их записи может немного отличаться, могут быть добавлены или убраны отдельные поля, но концепция остаётся неизменной.

Общий вид всей структуры тест-кейса представлен на рисунке 2.4.b.

![Рисунок 2.4.b — Общий вид тест-кейса, Святослав Куликов, EPAM](https://lh3.googleusercontent.com/m1XaMn-Lze93opUD_0eXCRWjoKTBG2IHpZVE1j_zcgSsKO_Ui6cteoCo69yPMOpen6P0LRjRfAxlNJxxlJVHHhJR8izphVPQMyTdHZbzkBB4M9RW7xP98VlKl-eJfHiuq2BPzvPMBRuR5tzZFe3x6LHJTDcL_EIwvS2W8a2Wc6cGJIG1oTL9-djErLST6qByQwoLbEc3EZ0xXHjLbCK6gQdWnHcHWqJWDDCaoeVjef-u73RJB4euGTtMC21t0_GYyV72NokWVokvZigQ61LrnIaFoJK7Us6st_R0Zh4iGi7Mkp9lSqjhW2GqqGuoEgcrK3REtAl8N-ExnDsGmrRQ3fgygP054RtcdLIvchGzk6J53t_HRMc4SVny2LRbtF3xy9YaqLpzaJthYCCi0e-T4glHlCSQFFUrFbtd2e0iQXUYHSQ7fbiivJwu-8N8HUbfbHM-KzqtgQM3lDtg98Ry8qOoRSmA25DGMh8yV9e_ypKEbRSXXoNE5NLxN0pqtukMWinzSjI_saXiAqeCwW8l1cTHTtAyBv_6Bai9DhkKk6x2nr3iySMjUFWb1a9OzCYgiFKXV7J-8yf_zs6aN5QsFeYzIxCPoHn09qVbbRmssHWxIRF2q7OyeDGHJRXr6RCNyVLoWxwdCqc9cdQeyCvuGq0N44dqMA3p=w951-h563-no)

Теперь рассмотрим каждый атрибут подробно.

**Идентификатор** (identifier) представляет собой уникальное значение, позволяющее однозначно отличить один тест-кейс от другого и используемое во всевозможных ссылках. В общем случае идентификатор тест-кейса может представлять собой просто уникальный номер, но (если позволяет инструментальное средство управления тест-кейсами) может быть и куда сложнее: включать префиксы, суффиксы и иные осмысленные компоненты, позволяющие быстро определить цель тест-кейса и часть приложения (или требований), к которой он относится (например: UR216_S12_DB_Neg).

**Приоритет** (priority) показывает важность тест-кейса. Он может быть выражен буквами (A, B, C, D, E), цифрами (1, 2, 3, 4, 5), словами («крайне высокий», «высокий», «средний», «низкий», «крайне низкий») или иным удобным способом. Количество градаций также не фиксировано, но чаще всего лежит в диапазоне от трёх до пяти.

Приоритет тест-кейса может коррелировать с:
- важностью требования, пользовательского сценария или функции, с которыми связан тест-кейс;
- потенциальной важностью дефекта, на поиск которого направлен тест-кейс;
- степенью риска, связанного с проверяемым тест-кейсом требованием, сценарием или функцией.

Основная задача этого атрибута — упрощение распределения внимания и усилий команды (более высокоприоритетные тест-кейсы получают их больше), а также упрощение планирования и принятия решения о том, чем можно пожертвовать в некоей форс-мажорной ситуации, не позволяющей выполнить все запланированные тест-кейсы.

**Связанное с тест-кейсом требование** (requirement) показывает то основное требование, проверке выполнения которого посвящён тест-кейс (основное — потому, что один тест-кейс может затрагивать несколько требований). Наличие этого поля улучшает такое свойство тест-кейса, как прослеживаемость.

Частые вопросы, связанные с заполнением этого поля, таковы:
- Можно ли его оставить пустым? Да. Тест-кейс вполне мог разрабатываться вне прямой привязки к требованиям, и (пока?) значение этого поля определить сложно. Хоть такой вариант и не считается хорошим, он достаточно распространён.
- Можно ли в этом поле указывать несколько требований? Да, но чаще всего стараются выбрать одно самое главное или «более высокоуровневое» (например, вместо того, чтобы перечислять R56.1, R56.2, R56.3 и т.д., можно просто написать R56). Чаще всего в инструментах управления тестами это поле представляет собой выпадающий список, где можно выбрать только одно значение, и этот вопрос становится неактуальным. К тому же многие тест-кейсы всё же направлены на проверку строго одного требования, и для них этот вопрос также неактуален.   

**Модуль и подмодуль приложения** (module and submodule) указывают на части приложения, к которым относится тест-кейс, и позволяют лучше понять его цель.

Идея деления приложения на модули и подмодули проистекает из того, что в сложных системах практически невозможно охватить взглядом весь проект целиком, и вопрос «как протестировать это приложение» становится недопустимо сложным. Тогда приложение логически разделяется на компоненты (модули), а те, в свою очередь, на более мелкие компоненты (подмодули). И вот уже для таких небольших частей приложения придумать чек-листы и создать хорошие тест-кейсы становится намного проще.

Как правило, иерархия модулей и подмодулей создаётся как единый набор для всей проектной команды, чтобы исключить путаницу из-за того, что разные люди будут использовать разные подходы к такому разделению или даже просто разные названия одних и тех же частей приложения. 

Теперь — самое сложное: как выбираются модули и подмодули. В реальности проще всего отталкиваться от архитектуры и дизайна приложения. Например, в уже знакомом нам приложении можно выделить такую иерархию модулей и под-модулей:

- Механизм запуска:
   - механизм анализа параметров;
   - механизм сборки приложения;
   - механизм обработки ошибочных ситуаций.
- Механизм взаимодействия с файловой системой:
   - механизм обхода дерева SOURCE_DIR;
   - механизм обработки ошибочных ситуаций. 
- Механизм преобразования файлов:
   - механизм определения кодировок;
   - механизм преобразования кодировок;
   - механизм обработки ошибочных ситуаций.
- Механизм ведения журнала:
   - механизм записи журнала;
   - механизм отображения журнала в консоли;
   - механизм обработки ошибочных ситуаций. 

Согласитесь, что такие длинные названия с постоянно повторяющимся словом «механизм» читать и запоминать сложно. Перепишем:

- Стартер:
   - анализатор параметров;
   - сборщик приложения;
   - обработчик ошибок.
- Сканер:
   - o обходчик;
   - o обработчик ошибок.
- Преобразователь:
   - детектор;
   - конвертер;
   - обработчик ошибок.
- Регистратор:
   - дисковый регистратор;
   - консольный регистратор;
   - обработчик ошибок.

Но что делать, если мы не знаем «внутренностей» приложения (или не очень разбираемся в программировании)? Модули и подмодули можно выделять на основе графического интерфейса пользователя (крупные области и элементы внутри них), на основе решаемых приложением задач и подзадач и т.д. Главное, чтобы эта логика была одинаковым образом применена ко всему приложению.

> Внимание! Частая ошибка! Модуль и подмодуль приложения — это НЕ действия, это именно структурные части, «куски» приложения. В заблуждение вас могут ввести такие названия, как, например, «печать, настройка принтера» (но здесь имеются в виду именно части приложения, отвечающие за печать и за настройку принтера (и названы они отглагольными существительными), а не процесс печати или настройки принтера).
> 
> Сравните (на примере человека): «дыхательная система, лёгкие» — это модуль и подмодуль, а «дыхание», «сопение», «чихание» — нет; «голова, мозг» — это модуль и подмодуль, а «кивание», «думание» — нет. 

Наличие полей «Модуль» и «Подмодуль» улучшает такое свойство тест-кейса, как прослеживаемость.

**Заглавие (суть) тест-кейса** (title) призвано упростить и ускорить понимание основной идеи (цели) тест-кейса без обращения к его остальным атрибутам. Именно это поле является наиболее информативным при просмотре списка тест-кейсов.

Сравните.

| Плохо | Хорошо |
| --- | ---|
| Тест 1 | Запуск, одна копия, верные параметры |
| Тест 2 | Запуск одной копии с неверными путями |
| Тест 78 (улучшенный) | Запуск, много копий, без конфликтов |
| Остановка | Остановка по Ctrl+C |
| Закрытие | Остановка закрытием консоли |

Заглавие тест-кейса может быть полноценным предложением, фразой, набором словосочетаний — главное, чтобы выполнялись следующие условия:
- Информативность.
- Хотя бы относительная уникальность (чтобы не путать разные тест-кейсы). 

> Внимание! Частая ошибка! Если инструмент управления тест-кейсами не требует писать заглавие, его всё равно надо писать. Тест-кейсы без заглавий превращаются в мешанину информации, использование которой сопряжено с колоссальными и совершенно бессмысленными затратами.

И ещё одна небольшая мысль, которая может помочь лучше формулировать заглавия. В дословном переводе с английского «test case» обозначает «тестовый случай (ситуация)». Так вот, заглавие как раз и описывает этот случай (ситуацию), т.е. что происходит в тест-кейсе, какую ситуацию он проверяет.

**Исходные данные, необходимые для выполнения тест-кейса** (precondition, preparation, initial data, setup), позволяют описать всё то, что должно быть подготовлено до начала выполнения тест-кейса, например:
- Состояние базы данных.
- Состояние файловой системы и её объектов.
- Состояние серверов и сетевой инфраструктуры.  

То, что описывается в этом поле, готовится БЕЗ использования тестируемого приложения, и таким образом, если здесь возникают проблемы, нельзя писать отчёт о дефекте в приложении. Эта мысль очень и очень важна, потому поясним её простым жизненным примером. Представьте, что вы дегустируете конфеты. В поле «исходные данные» можно прописать «купить конфеты таких-то сортов в таком-то количестве». Если таких конфет нет в продаже, если закрыт магазин, если не хватило денег и т.д. — всё это НЕ проблемы вкуса конфет, и нельзя писать отчёт о дефекте конфет вида «конфеты невкусные потому, что закрыт магазин».

> Некоторые авторы не следуют этой логике и допускают в приготовлениях работу с тестируемым приложением. И здесь нет «правильного варианта» — просто в одной традиции решено одним образом, в другой — другим. Во многом это — ещё и терминологическая проблема: «preparation», «initial data» и «setup» вполне логично выполнять без участия тестируемого приложения, в то время как «precondition» по смыслу ближе к описанию состояния тестируемого приложения. В реальной рабочей обстановке вам достаточно будет прочитать несколько тест-кейсов, уже созданных вашими коллегами, чтобы понять, какой точки зрения на данный вопрос они придерживаются.

**Шаги тест-кейса** (steps) описывают последовательность действий, которые необходимо реализовать в процессе выполнения тест-кейса. Общие рекомендации по написанию шагов таковы:
- шагов (запуск приложения, очевидные операции с интерфейсом и т.п.);
- даже если в тест-кейсе всего один шаг, нумеруйте его (иначе возрастает вероятность в будущем случайно «приклеить» описание этого шага к новому тексту);
- если вы пишете на русском языке, используйте безличную форму (например, «открыть», «ввести», «добавить» вместо «откройте», «введите», «добавьте»), в английском языке не надо использовать частицу «to» (т.е. «запустить приложение» будет «start application», не «to start application»);
- соотносите степень детализации шагов и их параметров с целью тест-кейса, его сложностью, уровнем и т.д. — в зависимости от этих и многих других факторов степень детализации может варьироваться от общих идей до пре-дельно чётко прописанных значений и указаний;
- ссылайтесь на предыдущие шаги и их диапазоны для сокращения объёма текста (например, «повторить шаги 3–5 со значением…»);
- пишите шаги последовательно, без условных конструкций вида «если… то…».

> Внимание! Частая ошибка! Категорически запрещено ссылаться на шаги из других тест-кейсов и другие тест-кейсы целиком: если те, другие тест-кейсы будут изменены или удалены, ваш тест-кейс начнёт ссылаться на неверные данные или в пустоту, а если в процессе выполнения те, другие тест-кейсы или шаги приведут к возникновению ошибки, вы не сможете закончить выполнение вашего тест-кейса.

**Ожидаемые результаты** (expected results) по каждому шагу тест-кейса описывают реакцию приложения на действия, описанные в поле «шаги тест-кейса». Номер шага соответствует номеру результата.

По написанию ожидаемых результатов можно порекомендовать следующее:
- описывайте поведение системы так, чтобы исключить субъективное толкование (например, «приложение работает верно» — плохо, «появляется окно с надписью…» — хорошо);
- пишите ожидаемый результат по всем шагам без исключения, если у вас есть хоть малейшие сомнения в том, что результат некоего шага будет совершенно тривиальным и очевидным (если вы всё же пропускаете ожидаемый результат для какого-то тривиального действия, лучше оставить в списке ожидаемых результатов пустую строку — это облегчает восприятие);
- пишите кратко, но не в ущерб информативности;
- избегайте условных конструкций вида «если… то…». 

> Внимание! Частая ошибка! В ожидаемых результатах ВСЕГДА описывается КОРРЕКТНАЯ работа приложения. Нет и не может быть ожидаемого результата в виде «приложение вызывает ошибку в операционной системе и аварийно завершается с потерей всех пользовательских данных». 
>
> При этом корректная работа приложения вполне может предполагать отображение сообщений о неверных действиях пользователя или неких критических ситуациях. Так, сообщение "Невозможно сохранить файл по указанному пути: на целевом носителе недостаточно свободного места" — это не ошибка приложения, это его совершенно нормальная и правильная работа. Ошибкой приложения (в этой же ситуации) было бы отсутствие такого сообщения, и/или повреждение, или потеря записываемых данных. 

Для более глубокого понимания принципов оформления тест-кейсов рекомендуется прямо сейчас ознакомиться с главой 2.4.8 «Типичные ошибки при разработке чек-листов, тест-кейсов и наборов тест-кейсов».

**2.4.5. Свойства качественных тест-кейсов**

Даже правильно оформленный тест-кейс может оказаться некачественным, если в нём нарушено одно из следующих свойств.

Правильный технический язык, точность и единообразие формулировок. Это свойство в равной мере относится и к требованиям, и к тест-кейсам, и к отчётам о дефектах — к любой документации. Основные идеи уже были описаны (см. главу «Атрибуты (поля) тест-кейсов»), а из самого общего и важного напомним и добавим:

- пишите лаконично, но понятно;
- используйте безличную форму глаголов (например, «открыть» вместо «откройте»);
- обязательно указывайте точные имена и технически верные названия элементов приложения;
- не объясняйте базовые принципы работы с компьютером (предполагается, что ваши коллеги знают, что такое, например, «пункт меню» и как с ним работать);
- везде называйте одни и те же вещи одинаково (например, нельзя в одном тест-кейсе некий режим работы приложения назвать «графическое представление», а в другом тот же режим — «визуальное отображение», т.к. многие люди могут подумать, что речь идёт о разных вещах);
- следуйте принятому на проекте стандарту оформления и написания тест-кейсов (иногда такие стандарты могут быть весьма жёсткими: вплоть до регламентации того, названия каких элементов должны быть приведены в двойных кавычках, а каких — в одинарных). 

**Баланс между специфичностью и общностью**. Тест-кейс считается тем более специфичным, чем более детально в нём расписаны конкретные действия, конкретные значения и т.д., т.е. чем в нём больше конкретики. Соответственно, тест-кейс считается тем более общим, чем в нём меньше конкретики. Рассмотрим поля «шаги» и «ожидаемые результаты» двух тест-кейсов (подумайте, какой тест-кейс вы бы посчитали хорошим, а какой — плохим и почему):

Тест-кейс 1 "Конвертация из всех поддерживаемых кодировок":

Приготовления: 
- Создать папки C:/A, C:/B, C:/C, C:/D.
- Разместить в папке C:/D файлы 1.html, 2.txt, 3.md из прилагаемого архива.

| Шаги | Ожидаемые результаты |
| --- | ---|
| 1. Запустить приложение, выполнив команду "php converter.php c:/a c:/b c:c/converter.log". | 1. Отображается консольный журнал приложения с сообщением "текущее_время started, source dir c:/a, destination dir c:/b, log file c:/c/converter.log, в котором появляется запись "текущее_время started, source dir c:/a, destination dir c:/b, log file c:/c/converter.log" |
| 2. Скопировать файлы 1.html, 2.txt, 3.md из папки C:/D в папку C:/A. | 2. Файлы 1.html, 2.txt, 3.md появляются в папке c:/a, затем пропадают оттуда и появляются в папке с:/b. В консольном журнале и файле c:/c/converter.log появляются сообщения (записи) "текущее_время proceccing 1.html (KOI8-R)», «текущее_время processing 2.txt (CP-1251)», «текущее_время processing 3.md (CP-866)». | 
| 3. Остановить приложение нажатием Ctrl+C. | 3. В файле C:/C/converter.log появляется запись «текущее_время closed». Приложение завершает работу. |

Тест-кейс 2 "Конвертация из всех поддерживаемых кодировок":

| Шаги | Ожидаемые результаты |
|-|-|
|  1. Выполнить конвертацию трех файлов допустимого размера в трех разных кодировках всех трех допустимых форматов. | 1. Файлы перемеющаются в папку-приемник, кодировка всех файлов меняется на UTF-8. |

Если вернуться к вопросу "какой тест-кейс вы бы посчитали хорошим, а какой — плохим и почему", то ответ таков: оба тест-кейса плохие потому, что первый является слишком специфичным, а второй — слишком общим. Можно сказать, что здесь до абсурда доведены идеи низкоуровневых и высокоуровневых тест-кейсов.

Почему плоха излишняя специфичность (тест-кейс 1):

- при повторных выполнениях тест-кейса всегда будут выполняться строго одни и те же действия со строго одними и теми же данными, что снижает вероятность обнаружения ошибки; 
- возрастает время написания, доработки и даже просто прочтения тест-кейса;
- в случае выполнения тривиальных действий опытные специалисты тратят дополнительные мыслительные ресурсы в попытках понять, что же они упустили из виду, т.к. они привыкли, что так описываются только самые сложные и неочевидные ситуации. 

Почему плоха излишняя общность (тест-кейс 2):
- тест-кейс сложен для выполнения начинающими тестировщиками или даже опытными специалистами, лишь недавно подключившимися к проекту;
- недобросовестные сотрудники склонны халатно относиться к таким тест-кейсам;
- тестировщик, выполняющий тест-кейс, может понять его иначе, чем было задумано автором (и в итоге будет выполнен фактически совсем другой тест-кейс).

Выход из этой ситуации состоит в том, чтобы придерживаться золотой середины (хотя, конечно же, какие-то тесты будут чуть более специфичными, какие-то — чуть более общими). Вот пример такого срединного подхода:

Тест-кейс 3 "Конвертация из всех поддерживаемых кодировок":

Приготовления:
- Создать в корне любого диска четыре отдельные папки для входных файлов, выходных файлов, файла журнала и временного хранения тестовых файлов.
- Распаковать содержимое прилагаемого архива в папку для временного хранения тестовых файлов.

| Шаги | |
| - | - |
| 1) Запустить приложение, указав в параметрах соответствующие пути из приготовления к тесту (имя файла журнала — произвольное). | Приложение запускается и выводит сообщение о своем запуске в консоль и файл журнала. |
| 2) Скопировать файлы из папки для времен-ного хранения в папку для входных файлов. | Файлы из папки для входных файлов перемещаются в папку для выходных файлов, в консоли и файле журнала отображаются сообщения о конвертации каждого из файлов с указанием его исходной кодировки. |
| 3) Остановить приложение. | Приложение выводит сообщение о завершении работы в файл журнала и завершает работу. |

В этом тест-кейсе есть всё необходимое для понимания и выполнения, но при этом он стал короче и проще для выполнения, а отсутствие строго указанных значений приводит к тому, что при многократном выполнении тест-кейса (особенно — разными тестировщиками) конкретные параметры будут менять свои значения, что увеличивает вероятность обнаружения ошибки.

Ещё раз главная мысль: сами по себе специфичность или общность тест-кейса не являются чем-то плохим, но резкий перекос в ту или иную сторону снижает качество тест-кейса.

**Баланс между простотой и сложностью**. Здесь не существует академических определений, но принято считать, что простой тест-кейс оперирует одним объектом (или в нём явно виден главный объект), а также содержит небольшое количество тривиальных действий; сложный тест-кейс оперирует несколькими равноправными объектами и содержит много нетривиальных действий.

Преимущества простых тест-кейсов:
- их можно быстро прочесть, легко понять и выполнить;
- они понятны начинающим тестировщикам и новым людям на проекте;
- они делают наличие ошибки очевидным (как правило, в них предполагается выполнение повседневных тривиальных действий, проблемы с которыми видны невооружённым взглядом и не вызывают дискуссий);
- они упрощают начальную диагностику ошибки, т.к. сужают круг поиска.

Преимущества сложных тест-кейсов:
- при взаимодействии многих объектов повышается вероятность возникновения ошибки;
- пользователи, как правило, используют сложные сценарии, а потому сложные тесты более полноценно эмулируют работу пользователей;
- программисты редко проверяют такие сложные случаи (и они совершенно не обязаны это делать).

Рассмотрим примеры.

Слишком простой тест-кейс "Запуск приложения":

| Шаги | Ожидаемые результаты |
|-|-|
|  1) Запустить приложение. | 1) Приложение запускается. |

Слишком сложный тест-кейс "Повторная конвертация":

Приготовления:
- Создать в корне любого диска три отдельные папки для входных файлов, выходных файлов, файла журнала.
- Подготовить набор из нескольких файлов максимального поддерживаемого размера поддерживаемых форматов с поддерживаемыми кодировками, а также нескольких файлов допустимого размера, но недопустимого формата.

| Шаги | Ожидаемые результаты |
|-|-|
| 1) Запустить приложение, указав в параметрах соответствующие пути из приготовления к тесту (имя файла журнала - произвольное). | 1) ... |
| 2) Скопировать в папку для входных файлов несколько файлов допустимого формата. | 2) Файлы постепенно перемещаются из входной в выходнную папку, в консоли и файле журнала появляются сообщения об успешной конвертации файлов. | 
| 3) Переместить сконвертированные файлы из папки с результирующими файлами в папку для входных файлов.  | 3) Файлы постепенно перемещаются из входной в выходнную папку, в консоли и файле журнала появляются сообщения об успешной конвертации файлов. | 
| 4) Переместить сконвертированные файлы из папки с результирующими файлами в папку для входных файлов. | 4) ... |
| 5) Переместить все файлы из папки с набором файлов для теста в папку для входных файлов. | Файлы постепенно перемещаются из входной в выходнную папку, в консоли и файле журнала появляются сообщения об успешной конвертации файлов допустимого формата и сообщения об игнорировании файлов недопустимого формата. |
| 6) Переместить конвертированные файлы из папки с результирующими файлами в папку для входных файлов. | 6) Файлы постепенно перемещаются из входной в выходнную папку, в консоли и файле журнала появляются сообщения об успешной конвертации файлов допустимого формата и сообщения об игнорировании файлов недопустимого формата. |

Этот тест-кейс одновременно является слишком сложным по избыточности действий и по спецификации лишних данных и операций.

Примером хорошего простого тест-кейса может служить тест-кейс 3 из пункта про специфичность и общность.

Пример хорошего сложного тест-кейса может выглядеть так. "Много копий приложения, конфликт файловых операций". Приготовления:

1. Создать в корне любого диска три отдельные папки для входных файлов, выходных файлов, файла журнала.
2. Подготовить набор из нескольких файлов максимального поддерживаемого размера поддерживаемых форматов с поддерживаемыми кодировками.

| Шаги | Ожидаемые результаты |
|-|-|
| 1) Запустить первую копию приложения, указав в параметрах соответствующие пути из приготовления к тесту (имя файла журнала — произвольное). |-|
| 2) Запустить вторую копию приложения с теми же параметрами (см. шаг 1). |-|
| 3) Запустить третью копию приложения с теми же параметрами (см. шаг 1). | 3) Все три копии приложения запускаются, в файле журнала появляются последовательно три записи о запуске приложения. |
| 4) Изменить приоритет процессов второй (“high”) и третьей (“low”) копий. |-|
| 5) Скопировать подготовленный набор исходных файлов в папку для входных файлов. | Файлы постепенно перемещаются из входной в выходную папку, в консоли и файле журнала появляются сообщения об успешной конвертации файлов, а также (возможно) сообщения вида: <br> a. "source file inaccessible, retrying". <br> b. "destination file inaccessible, retrying". <br> c. "log file inaccessible, retrying". <br><br> Ключевым показателем корректной работы является успешная конвертация всех файлов, а также появление в консоли и файле журнала сообщений об успешной конвертации каждого файла (от одной до трех записей на каждый файл). <br><br> Сообщения (предупреждения) о недоступности входного файла, выходного файла или файла журнала также являются показателем корректной работы приложения, однако их количество зависит от многих внешних факторов и не может быть спрогнозировано заранее. |

Иногда более сложные тест-кейсы являются также и более специфичными, но это лишь общая тенденция, а не закон. Также нельзя по сложности тест-кейса однозначно судить о его приоритете (в нашем примере хорошего сложного тест-кейса он явно будет иметь очень низкий приоритет, т.к. проверяемая им ситуация является искусственной и крайне маловероятной, но бывают и сложные тесты с самым высоким приоритетом).

Как и в случае специфичности и общности, сами по себе простота или сложность тест-кейсов не являются чем-то плохим (более того — рекомендуется начинать разработку и выполнение тест-кейсов с простых, а затем переходить ко всё более и более сложным), однако излишняя простота и излишняя сложность также снижают качество тест-кейса.

**«Показательность» (высокая вероятность обнаружения ошибки)**. Начиная с уровня тестирования критического пути, можно утверждать, что тест-кейс является тем более хорошим, чем он более показателен (с большей вероятностью обнаруживает ошибку). Именно поэтому мы считаем непригодными слишком простые тест-кейсы — они непоказательны. 

Пример непоказательного (плохого) тест-кейса "Запуск и остановка приложения": 

|Шаги|Ожидаемые результаты|
|-|-|
| 1) Запустить приложение с корректными пара-метрами. | 1) Приложение запускается. |
| 2) Завершить работу приложения. | 2) Приложение завершает работу. |

Пример показательного (хорошего) тест-кейса "Запуск с некорректными параметрами, несуществующие пути": 

|Шаги|Ожидаемые результаты|
|-|-|
| 1) Запустить приложение со всеми тремя параметрами (SOURCE_DIR, DESTINA-TION_DIR, LOG_FILE_NAME), значения которых указывают на несуществующие в файловой системе пути (например: z:\src\, z:\dst\, z:\log.txt при условии, что в системе нет логического диска z). | 1) В консоли отображаются нижеуказанные сообщения, приложение завершает работу. Сообщения: <br> a. SOURCE_DIR: directory not exists or inaccessible. <br> b. DESINATION_DIR: directory not exists or inaccessible. <br> c. LOG_FILE_NAME: wrong file name or inaccessible path. |

Обратите внимание, что показательный тест-кейс по-прежнему остался достаточно простым, но он проверяет ситуацию, возникновение ошибки в которой несравненно более вероятно, чем в ситуации, описываемой плохим непоказательным тест-кейсом.

Также можно сказать, что показательные тест-кейсы часто выполняют какие-то «интересные действия», т.е. такие действия, которые едва ли будут выполнены просто в процессе работы с приложением (например: «сохранить файл» — это обычное тривиальное действие, которое явно будет выполнено не одну сотню раз даже самими разработчиками, а вот «сохранить файл на носитель, защищённый от записи», «сохранить файл на носитель с недостаточным объёмом свободного пространства», «сохранить файл в папку, к которой нет доступа» — это уже гораздо более интересные и нетривиальные действия).

**Последовательность в достижении цели**. Суть этого свойства выражается в том, что все действия в тест-кейсе направлены на следование единой логике и достижение единой цели и не содержат никаких отклонений. Примерами правильной реализации этого свойства могут служить представленные в этом разделе в избытке примеры хороших тест-кейсов. А нарушение может выглядеть так. "Конвертация из всех поддерживаемых кодировок": 

Приготовления:
- Создать в корне любого диска четыре отдельные папки для входных файлов, выходных файлов, файла журнала и временного хранения тестовых файлов.
- Распаковать содержимое прилагаемого архива в папку для временного хранения тестовых файлов. 

|Шаги|Ожидаемые результаты|
|-|-|
|1) Запустить приложение, указав в параметрах соответствующие пути из приготовления к тесту (имя файла журнала — произвольное).| 1) Приложение запускается и выводит сообщение о своем запуске в консоль и файл журнала.|
|2) Скопировать файлы из папки для времен-ного хранения в папку для входных файлов.| 2) Файлы из папки для входных файлов перемещаются в папку для выходных файлов, в консоли и файле журнала отображаются сообщения о конвертации каждного из файлов с указанием его исходной кодировки.|
|3) Остановить приложение.| 3) Приложение выводит сообщение о завершении работы в файл журнала и завершает работу.|
|4) Удалить файл журнала.|-|
|5) Повторно запустить приложение с теми же параметрами.| 5) Приложение запускается и выводит сообщение о своем запуске в консоль и заново созданный файл журнала.|
|6) Остановить приложение.| 6) Приложение выводит сообщение о заврешении работы в файл журнала и завершает работу.|

**Отсутствие лишних действий**. Чаще всего это свойство подразумевает, что не нужно в шагах тест-кейса долго и по пунктам расписывать то, что можно заменить одной фразой: 

|Плохо|Хорошо|
|-|-|
| 1) Указать в качестве первого параметра приложения путь к папке с исходными файлами.| 1) Запустить приложение со всеми тремя корректными параметрами (например, c:\src\, c:\dist\, c:\log.txt при условии, что соответствующие папки существуют и доступны приложению).|
| 2) Указать в качестве второго параметра приложения путь к папке с конечными файлами.|-|
| 3) Указать в качестве третьего параметра приложения путь к файлу журнала.|-|
| 4) Запустить приложение.|-|

Вторая по частоте ошибка — начало каждого тест-кейса с запуска приложения и подробного описания по приведению его в то или иное состояние. В наших примерах мы рассматриваем каждый тест-кейс как существующий в единственном виде в изолированной среде, и потому вынуждены осознанно допускать эту ошибку (иначе тест-кейс будет неполным), но в реальной жизни на запуск приложения будут свои тесты, а длинный путь из многих действий можно описать как одно действие, из контекста которого понятно, как это действие выполнить.

Следующий пример тест-кейса не относится к нашему «Конвертеру файлов», но очень хорошо иллюстрирует эту мысль: 

|Плохо|Хорошо|
|-|-|
| 1)  Запустить приложение.| 1) Открыть DOCX-файл с тремя и более страницами.|
| 2) Выбрать в меню пункт «Файл».|-|
| 3) Выбрать подпункт «Открыть».|-|
| 4) Перейти в папку, в которой находится хотя бы один файл формата DOCX с тремя и более страницами.|-|

И сюда же можно отнести ошибку с повторением одних и тех же приготовлений во множестве тест-кейсов (да, по описанным выше причинам в примерах мы снова вынужденно делаем так, как в жизни делать не надо). Куда удобнее объединить тесты в набор и указать приготовления один раз, подчеркнув, нужно или нет их выполнять перед каждым тест-кейсом в наборе.

> Проблема с подготовительными (и финальными) действиями идеально решена в автоматизированном модульном тестировании с использованием фреймворков наподобие JUnit или TestNG — там существует специальный «механизм фиксаций» (fixture), автоматически выполняющий указанные действия перед каждым отдельным тестовым методом (или их совокупности) или после него. 

**Неизбыточность по отношению к другим тест-кейсам**. В процессе создания множества тест-кейсов очень легко оказаться в ситуации, когда два и более тест-кейса фактически выполняют одни и те же проверки, преследуют одни и те же цели, направлены на поиск одних и тех же проблем. Способ минимизации количества таких тест-кейсов подробно описан в главе «Виды и направления тестирования»  (см. такие техники тестирования, как использование классов эквивалентности и граничных условий). 

Если вы обнаруживаете несколько тест-кейсов, дублирующих задачи друг друга, лучше всего или удалить все, кроме одного, самого показательного, или перед удалением остальных на их основе доработать этот выбранный самый показательный тест-кейс.

**Демонстративность (способность демонстрировать обнаруженную ошибку очевидным образом)**. Ожидаемые результаты должны быть подобраны и сформулированы таким образом, чтобы любое отклонение от них сразу же бросалось в глаза и становилось очевидным, что произошла ошибка. Сравните выдержки из двух тест-кейсов.

Выдержка из недемонстративного тест-кейса:

|Шаги|Ожидаемые результаты|
|-|-|
| 1) Разместить в файле текст «Пример длинного текста, содержащего символы русского и английского алфавита вперемешку» в кодировке KOI8-R (в слове «Пример» буквы «р» — английские). |-|
| 2) Сохранить файл под именем «test. txt» и отправить файл на конвертацию. | 2) Приложение игнорирует файл. |
| 3) Переименовать файл в "test.txt". | 3) Текст принимает корректный вид в кодировке UTF-8 с учетом английских букв. |

Выдержка из демонстративного тест-кейса: 

|Шаги|Ожидаемые результаты|
|-|-|
| 1) Разместить в файле текст «Ё╥╔═┼╥ ╘┼╦╙╘┴.» (Эти символы представляют со-бой словосочетание «Пример текста.» в коди-ровке KOI8-R, прочитанной как CP866). | - |
| 2) отправить файл на конвертацию. | 2) Текст принимает вид: "Пример текста" (кодировка UTF8)|

В первом случае тест-кейс плох не только расплывчатостью формулировки «корректный вид в кодировке UTF-8 с учётом английских букв», там также очень легко допустить ошибки при выполнении: 
- забыть сконвертировать вручную входной текст в KOI8-R;
- не заметить, что в первый раз расширение начинается с пробела;
- забыть заменить в слове «Пример» буквы «р» на английские;
- из-за расплывчатости формулировки ожидаемого результата принять ошибочное, но выглядящее правдоподобно поведение за верное.

Второй тест-кейс чётко ориентирован на свою цель по проверке конвертации (не содержит странной проверки с игнорированием файла с неверным расширением) и описан так, что его выполнение не представляет никаких сложностей, а любое отклонение фактического результата от ожидаемого будет сразу же заметно.

**Прослеживаемость**. Из содержащейся в качественном тест-кейсе информации должно быть понятно, какую часть приложения, какие функции и какие требования он проверяет. Частично это свойство достигается через заполнение соответствующих полей тест-кейса («Ссылка на требование», «Модуль», «Подмодуль»), но и сама логика тест-кейса играет не последнюю роль, т.к. в случае серьёзных нарушений этого свойства можно долго с удивлением смотреть, например, на какое требование ссылается тест-кейс, и пытаться понять, как же они друг с другом связаны.

Пример непрослеживаемого тест-кейса "Совмещение кодировок":

Приготовления: файл с несколькими допустимыми и недопустимыми кодировками.

|Требование|Модуль|Подмодуль|Шаги|Ожидаемые результаты|
|-|-|-|-|-|
|ПТ-4|Приложение|-|1) Передать файл на конвертацию.| 1) Допустимые кодировки конвертируются верно, недопустимые остаются без изменений.|

Да, этот тест-кейс плох сам по себе (в качественном тест-кейсе сложно получить ситуацию непрослеживаемости), но в нём есть и особые недостатки, затрудняющие прослеживаемость:
-  Ссылка на несуществующее требование (убедитесь сами, требования ПТ-4 нет - в приведенных на странице 55/297 требований заключительное требование - ПТ-3 - Пользовательское требование).
- В поле «Модуль» указано значение «Приложение» (по большому счёту можно было оставлять это поле пустым — это было бы столь же информативно), поле «Подмодуль» не заполнено.
- По заглавию и шагам можно предположить, что этот тест-кейс ближе всего к ДС-5.1 и ДС-5.3, но сформулированный ожидаемый результат не следует явно из этих требований.

Пример прослеживаемого тест-кейса "Запуск с некорректными параметрами, несуществуие пути": 

|Требование|Модуль|Подмодуль|Шаги|Ожидаемые результаты|
|-|-|-|-|-|
|ДС-2.4, ДС-3.2|Стартер|Обработчик ошибок| 1) Запустить приложение со всеми тремя параметрами, значения которых указывают на несуществующие в файловой системе пути.| 1) В консоли отображаются нежеуказанные сообщения, приложение завершает работу. Сообщения: <br> a. SOURCE_DIR: directory not exists or inaccessible. <br> DESTINATION_DIR: directory not exists or inaccessible. <br> c. LOG_FILE_NAME: wrong file name or inaccessible path.|

Можно подумать, что этот тест-кейс затрагивает ДС-2 и ДС-3 целиком, но в поле «Требование» есть вполне чёткая конкретизация, к тому же указанные модуль, подмодуль и сама логика тест-кейса устраняют оставшиеся сомнения.

Некоторые авторы также подчёркивают, что прослеживаемость тест-кейса связана с его неизбыточностью по отношению к другим тест-кейсам (намного проще дать ссылку на один уникальный тест-кейс, чем выбирать из нескольких очень похожих).

**Возможность повторного использования**. Это свойство редко выполняется для низкоуровневых тест-кейсов, но при создании высокоуровневых тест-кейсов можно добиться таких формулировок, при которых:
- тест-кейс будет пригодным к использованию с различными настройками тестируемого приложения и в различных тестовых окружениях;
- тест-кейс практически без изменений можно будет использовать для тестирования аналогичной функциональности в других проектах или других обла-стях приложения. 

Примером тест-кейса, который тяжело использовать повторно, может являться практически любой тест-кейс с высокой специфичностью.

Не самым идеальным, но очень наглядным примером тест-кейса, который может быть легко использован в разных проектах, может служить следующий тест-кейс "Запуск, все параметры некорректны": 

|Шаги|Ожидаемые результаты|
|-|-|
| 1) Запустить приложение, указав в качестве всех параметров заведомо некорректные значения.| 1) Приложение запускается, после чего выводит сообщение с описание сути проблемы с каждым из параметров и заврешает работу.|

**Повторяемость**. Тест-кейс должен быть сформулирован таким образом, чтобы при многократном повторении он показывал одинаковые результаты. Это свойство можно разделить на два подпункта:
- во-первых, даже общие формулировки, допускающие разные варианты выполнения тест-кейса, должны очерчивать соответствующие явные границы (например: «ввести какое-нибудь число» — плохо, «ввести целое число в диапазоне от -273 до +500 включительно» — хорошо);
- действия (шаги) тест-кейса по возможности не должны приводить к необратимым (или сложно обратимым) последствиям (например: удалению данных, нарушению конфигурации окружения и т.д.) — не стоит включать в тест-кейс такие «разрушительные действия», если они не продиктованы явным образом целью тест-кейса; если же цель тест-кейса обязывает нас к выполнению таких действий, в самом тест-кейсе должно быть описание действий по восстановлению исходного состояния приложения (данных, окружения). 

**Соответствие принятым шаблонам оформления и традициям**. С шаблонами оформления, как правило, проблем не возникает: они строго определены имеющимся образцом или вообще экранной формой инструментального средства управления тест-кейсами. Что же касается традиций, то они отличаются даже в разных командах в рамках одной компании, и тут невозможно дать иного совета, кроме как «почитайте уже готовые тест-кейсы перед тем как писать свои». В данном случае обойдёмся без отдельных примеров, т.к. выше и без того приведено много правильно оформленных тест-кейсов, а что касается нарушений этого свойства, то они прямо или косвенно описаны в главе «Типичные ошибки при разработке чек-листов, тест-кейсов и наборов тест-кейсов». 

**2.4.8. Типичные ошибки при разработке чек-листов, тест-кейсов и наборов тест-кейсов** 



Еще страницы 138-139.

09.10.2017. Перейти на [Главную страницу](./)