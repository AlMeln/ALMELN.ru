# Анализ граничных значений

В [учебных программах](/2016-08-14-educational-programs-exam-questions-and-literature.md) по дисциплине "Обеспечение качества и тестирование программ" есть темы для изучения - "Анализ граничных значений: типы границ, типы ошибок, правила составления тестов".

В программе обучения базового уровня International Software Testing Qualifications Board "Сертифицированный тестировщик" указано на необходимость:

- Создать тестовые сценарии для приведенных моделей программного обеспечения при помощи следующих методов проектирования тестов: (1) эквивалентное разбиение; (2) анализ граничных значений; (3) тестирование таблицы решений; (4) тестирование таблицы переходов.
- Объяснить назначение каждого из четырех методов, какие уровни и типы тестирования могут использовать данные методы, и каким образом может быть измерено покрытие при использовании данных методов.

Содержание:

1. [«Искусство тестирования программ», Глендфорд Майерс](#mayers)
2. [«Тестирование программного обеспечения. Фундаментальные концепции менеджмента бизнес-приложений», Сэм Канер, Джек Фолк и Енг Кек Нгуен](#kaner)
3. [«Lessons Learned in Software Testing: A Context-Driven Approach», Сэм Канер, Джеймс Маркус Бах, Брет Петтичорд](#kbp)
4. [«Тестирование Дот Ком, или Пособие по жестокому обращению с багами в интернет-стартапах», Роман Савин](#savin)

### "Искусство тестирования программ", Глендфорд Майерс <a name="mayers"></a>

Москва, Финансы и статистика, 1982 год. 63-74 страницы:

![](https://lh3.googleusercontent.com/Gmy5jdSIegZpdYaGGxHyIho9PL2tqBhARRwK5AM3N0C6iB8fYKwKauRl4tU6mYJ3M9U_r7P_s2vK0cOr0QeS1JkG14ZDS1Mi1hvbLSN9kxpAd65mC4wamY95gD_AZ4zsxE8xzqqKcy02eIEagXp8zPXI2wXxVJLD4PnBHJnySzgmHMW9aC19K52-SEguP7URvxcZUlP6INuhq4fnyuWKGDgkZJL9M5GrJul7fWwedWEKlVEzE4qmutEfGBbaGDkQMY9O6NeQhO2A31VKvix6u2yN4j8zonYNJ9AgyFn3e1Ev1e_-n9H5THjqKoRCm9uWkYpk4sfymWQWuVrjhijfTzrqZIq5yUnIfiU-jXwIgvRb9OGjGY0S0PWw2keMoXB1ZZQS_9Fybt9atzml6cfoUmMOVdqS1MbkD1PA6aYxWlwYUW0t6pyevum4JMkGv2IL6PFADrM5mh9BSkLNr_TDMK1aHrolYqmkKRWK4dFTzKPbyPsWmXqfH7ageaP5a40kVHNhewSql55yrRqFPEJmIRaOQw0ainfE6xQirz3F-Kbb_Mc1cNyrjU3vtha5WQkDUgp6T5y08-X40eWVEMQRyn-iO9LCWmoAbLe1I_AwzLumtJPKpHMG3o9oaNUFaDfO7ZDoVzkcOw7utPPzRR8KhbbodVqG631C=s579-no)

**Анализ граничных значений**

Как показывает опыт, тесты, исследующие *граничные условия*, приносят большую пользу, чем тесты, которые их не исследуют. Граничные условия - это ситуации, возникающие непосредственно на, выше или ниже границ входных и выходных классов эквивалентности. Анализ граничных значений отличается от эквивалентного разбиения в двух отношениях:

1. Выбор любого элемента в классе эквивалентности в качестве представительного при анализе граничных значений осуществляется таким образом, чтобы проверить тестом каждую границу этого класса.
2. При разработке тестов рассматривают не только входные условия (пространство входов), но и *пространство результатов* (то есть выходные классы эквивалентности).

Трудно описать "кухню" анализа граничных значений, так как это требует определенной степени творчества и специализации в рассматриваемой проблеме. (Следовательно, анализ граничных значений, как и многие другие аспекты тестирования, в значительной мере основываются на способностях человеческого интеллекта.) Тем не менее приведем несколько общих правил этого метода.

1. Построить тесты для границ области и тесты с неправильными входными данными для ситуаций незначительного выхода за границы области, если входное условие описывает область значений. Например, если правильная область входных значений есть ```-1.0``` - ```+1.0```, то написать тесты для ситуаций ```-1.0```, ```1.0```, ```-1,001``` и ```1,001```.

2. Построить тесты для минимального и максимального значений условий и тесты, большие и меньшие этих значений, если входное условие удовлетворяет дискретному ряду значений

   [^1]: "Дискретный ряд - это такой вариационный ряд, в основу построения которого положены признаки с прерывным изменением (дискретные признаки). К последним можно отнести тарифный разряд, количество детей в семье, число работников на предприятии и т.д. Эти признаки могут принимать только конечное число определенных значений", [Московский государственный университет печати](http://www.hi-edu.ru/e-books/xbook096/01/part-007.htm).

   . Например, если входной файл может содержать от 1 до 255 записей, то получить тесты для ```0```, ```1```, `255` и `256` записей.

3. Использовать правило 1 для каждого выходного условия. Например, если программа вычисляет ежемесячный расход и если минимум расхода составляет `0.00 дол.`, а максимум - `1165.25 дол.`, то построить тесты, которые вызывают расходы с `0.00 дол.` до `1165.25 дол.` Кроме того, построить, если это возможно, тесты, которые вызывают отрицательный расход и расход больше `1165.25 дол`. Заметим, что важно проверить границы пространства результатов, поскольку не всегда границы входных областей представляют такой же набор условий, как и границы выходных областей (например, при рассмотрении подпрограммы вычисления синуса). Не всегда также можно получить результат вне выходной области, но тем не менее стоит рассмотреть эту возможность.

4. Использовать правило 2 для каждого выходного условия. Например, если система информационного поиска отображает на экране терминала наиболее релевантные рефераты в зависимости от входного запроса, но никак не более четырех рефератов, то построить тесты, такие, чтобы программа отображала нуль, один и четыре реферата, и тест, который мог бы вызвать выполнение программы с ошибочным отображением пяти рефератов.

5. Если вход или выход программы есть упорядоченное множество (например, последовательный файл, линейный список, таблица), то сосредоточить внимание на первом и последнем элементах этого множества.

6. Попробовать свои силы в поиске других граничных условий.

Чтобы проиллюстрировать необходимость анализа граничных значений, можно использовать программу анализа треугольника, приведенную в главе 1.

Для задания треугольника входные значения должны быть целыми положительными числами, и сумма любых двух из них должна быть больше третьего. Если определены эквивалентные разбиения, то целесообразно определить одно разбиение, в котором это условие выполняется, и другое, в котором сумма двух целых не больше третьего. Следовательно, двумя возможными тестами являются `3-4-5` и `1-2-4`.

Тем не менее здесь есть вероятность пропуска ошибки. Иными словами, если выражение в программе было закодировано как ```A + B >= C``` вместо ```A + B > C```, то программа ошибочно сообщала бы нам, что числа 1-2-3 представляют правильный равносторонний треугольник.

Таким образом, существенное различие между анализом граничных значений и эквивалентным разбиением заключается в том, что анализ граничных значений исследует ситуации, возникающие _на и вблизи границ эквивалентных разбиенией_.

В качестве примера применения метода анализа граничный значений рассмотрим следующую спецификацию программы.

![Спецификация программы](https://lh3.googleusercontent.com/jEpEHYV-q1095EIPpYbsg9G0w5LNnyJlXmQR863Rm1lTUuwpIop6u1gsluDi8hNDzgx1574aqc8jDK_XYkq0hbIZrrZlsW2VI4FgFSzZrbMHXwmEWNB6yp8T9PHqxPwpqSSyOHdS7RLjGDvoOZh6VJXBNmfnh0rahekqg5DdWsWgAkiAH3iLTltnDq_CmbVAgFka_e6AYQkrjWvA3AP4N6PG-VRwhbMVDsL90ht5MT9hwCnxzzWR_sVaIBVZRICiksyG0aPFQH9dGwUh_fPTH3PNfU7U0elbTuCIzA9umPpN2SFVaJaUpDQ3xiyv4pYn8U2rVYMCFe_kUEOBq9TnL5cGnIqNhIni9F7ub1BcYhrXaqg_qzPnGrNjs9Ot6H1GhU1OysqwJeLJX1jejFgmkz0kJk1ATKW88GUrCzQ-4cQ_YG7DZ-rVYDwXjnJBmjMI5T1uYTyKUxiK_IyBsdlxqu35eeXjzLTYARaCHn5UMf_IwCKrdL9FK_BHaqTkuhOaHnZ3X1IeMVCF3hYN2ftzSROEpHdUTTdwIeOnPiC4gjeYvEXmE0sK2C0Fm4v9WsL1X7FzY-mdxxRMvBbifh6-HjqQQgQrvFna5WXjSCnZP7UHY2pRs-lEFnS8PgtXMDoMmlbPoiDGrhNPnEGg5ZjB2g5oYow1aHRp=w928-h734-no)

MTEST есть программа, которая сортирует различную информацию об экзаменах. Входом программы является файл, названный OCR, который содержит 80-символьные записи.

Первая запись представляет название; ее содержание используется как заголовок каждого выходного отчета.

Следующее множество записей описывает правильные ответы на экзамене. Каждая запись этого множества содержит "2" в качестве последнего символа. В первой записи в колонках 1-3 задается число ответов (может быть число вопросов? - прим. Мельников А.) (оно принимает значения от 1 до 999). Колонки 10-59 включают сведения о правильных ответах на вопросы с номерами 1-50 (любой символ воспринимается как ответ). Последующие записи содержат в колонках 10-59 сведения о правильных ответа на вопросы с номерами 51-100, 101-150 и так далее.

Третье множество записей описывает ответы каждого студента; любая запись этого набора имеет число "3" в восьмидесятой колонке. Для каждого студента первая запись в колонках 1-9 содержит его имя или номер (любые символы); в колонках 10-59 помещены сведения о результатах ответов студентов на вопросы с номерами 1-50.

Если в тесте предусмотрено более чем 50 вопросов, то последующие записи для студента описывают ответы 51-100, 101-150 и так даллее в колонках 10-59. Максимальное число студентов - 200. Форматы входных записей показаны на рисунке 4.4. Выходными записями являются:

1. отчет, упорядоченный в лексикографическом порядке идентификаторов студентов и показывающий качество ответов каждого студента (процент правильных ответов) и его ранг;
2. аналогичный отчет, но упорядоченный по качеству;
3. отчет, показывающий среднее значение, медиану и среднее квадратическое отклонение качества ответов;
4. отчет, упорядоченный по номерам вопросов и показывающий процент студентов, отвечающих правильно на каждый вопрос. (Конец спецификации.)

Начнем методичное чтение спецификации, выявляя входные условия:
- Первое граничное входное условие есть пустой входной файл.
- Второе граничное условие - карта (запись) названия; граничными условиями являются отсутствие карты названия, самое короткое и самое длинное название.
- Следующими входными условиями служат наличие записей о правильных ответах и наличие поля числа вопросов в первой записи ответов.
- 1-999 не является классом эквивалентности для числа вопросов, так как для каждого подмножества из 50 записей может иметь место что-либо специфическое (то есть необходимо много записей). Приемлемое разбиение вопросов на классы эквивалентности представляет разбиение на два подмножества: 1-50 и 51-999. Следовательно: необходимый тесты, где поле числа вопросов принимает значения `0`, `1`, `50`, `51` и `999`.

Эти тесты покрывают большинство граничных условий для записей о правильных ответа; однако, существуют три более интересные ситуации - отсутствие записей об ответах, наличие записей об ответах типа "много ответов на один вопрос" и наличие записей об ответах типа "мало ответов на один вопрос" (например, число вопросов - 60, и имеется три записи об ответах в первом случае и одна запись об ответах во втором). Таким образом, определены следующие тесты:

```
1. Пустой входной файл.
2. Отсутствует запись названия.
3. Название длиной в один символ.
4. Название длиной в 80 символов.
5. Экзамен из одного вопроса.
6. Экзамен из 50 вопросов.
7. Экзамен из 51 вопроса.
8. Экзамен из 999 вопросов.
9. 0 вопросов на экзамене.
10. Поле числа вопросов имеет нечисловые значения.
11. После записи названия нет записей о правильных ответах.
12. Имеются записи типа "много правильных ответов на один вопрос".
13. Имеются записи типа "мало правильных ответов на один вопрос".
```

Следующие входные условия относятся к ответам студентов. Тестами граничных значений в этом случае, по-видимому, должны быть:

```
14. 0 студентов
15. 1 студент
16. 200 студентов.
17. 201 студент.
18. Есть одна запись об ответе студента, но существует две записи о правильных ответах.
19. Запись об ответе вышеупомянутого студента первая в файле.
20. Запись об ответе вышеупомянутого студента последняя в файле.
21. Есть две записи об ответах студента, но существует только одна запись о правильном ответе.
22. Запись об ответах вышеупомянутого студента первая в файле.
23. Запись об ответах вышеупомянутого студента последняя в файле.
```

Можно также получить набор тестов для проверки выходных границ, хотя некоторые из выходных границ (например, пустой отчет 1) покрывается приведенными тестами. Граничными условиями для отчетов 1 и 2 являются:

```
0 студентов (так же, как тест 14);
1 студент (так же, как тест 15); 
200 студентов (так же как тест 16).
24. Оценки качества ответов всех студентов одинаковы.
25. Оценки качества ответов всех студентов различны.
26. Оценки качества ответов некоторых, но не всех студентов одинаковы (для проверки правильности вычисления рангов).
27. Студент получает оценку качества ответа 0.
28. Студент получает оценку качества ответа 100.
29. Студент имеет идентификатор наименьшей возможной длины (для проверки правильности упорядочения).
30. Студент имеет идентификатор наибольшей возможной длины.
31. Число студентов таково, что отчет имеет размер, несколько больший одной страницы (для того чтобы посмотреть случай печати на другой странице).
32. Число студентов такого, что отчет располагается на одной странице.
```

Граничные условия отчета 3 (среднее значение, медиана, среднее квадратическое отклонение):

```
33. Среднее значение максимально (качество ответов всех студентов наивысшее).
34. Среднее значение равно 0 (качество ответов всех студентов равно 0).
35. Среднее квадратическое отклонение равно своему максимуму (один студент получает оценку 0, а другой - 100).
36. Среднее квадратическое отклонение равно 0 (все студенты получают одну и ту же оценку).
```

Тесты 33 и 34 покрывают и границы медианы. Другой полезный тест описывает ситуацию, где существует 0 студентов (проверка деления на 0 при вычислении математического ожидания), но он идентичен тесту 14.

Проверка отчета 4 дает следующие тесты граничных значений:

```
37. Все студенты отвечают правильно на первый вопрос.
38. Все студенты неправильно отвечают на первый вопрос.
39. Все студенты правильно отвечают на последний вопрос.
40. Все студенты отвечают на последний вопрос неправильно.
41. Число вопросов таково, что размер отчета несколько больше одной страницы.
42. Число вопросов такого, что отчет располагается на одной странице.
```

Опытный программист, вероятно, соглаcится с той точкой зрения, что многие из этих 42 тестов позволяют выявить наличие общих ошибок, которые могут быть сделаны при разработке данной программы. Кроме того, большинство этих ошибок, вероятно, не было бы обнаружено, если бы использовался метод случайной генерации тестов или специальный метод генерации тестов. Анализ граничных значений, если он применен правильно, является одним из наиболее полезных методов проектирования тестов. Однако он часто оказывается неэффективным из-за того, что внешне выглядит простым. Читатель должен понимать, что граничные условия могут быть едва уловимы и, следовательно, определение их связано с большими трудностями.

### «Тестирование программного обеспечения. Фундаментальные концепции менеджмента бизнес-приложений», Сэм Канер, Джек Фолк и Енг Кек Нгуен <a name="kaner"></a>

Москва, ДиаСофт, 2001. 97, 181, 191-192 страницы:
![](https://lh3.googleusercontent.com/dpeO6RBu2RD1ESmNDXwJkn2uNbXdsERTX4JSxXdZi6CmOjSC7r01qkH5LO0Q2Xv4-nXbr9ufKeBx5LNxdNmRYqEjgbEho3OdWyT3O0eAgT91h7tkX9wTeAaMpNRy8anRcrCPjhj7jsVTRClgg_PAL45f_7ftp_q7aCgAk-l0ZDDv2ztyloIs0WXZffAYa0BkvyZxae0QlbZYdmbdNTxkQGfdLFk-KayofnGglbmslW4ADZjEDWxxjMclA834-hhj1D8AF-3zQNt3wlUl00IqTvuo-QJI7jtYtdhnSDtAP1dkPyl_1xqYkBm8XJmdaJVmcpJJ5ebPcuI35Y58_pxfmcBqNRcraupPG5Diqk86JTtFGdMB2Ngw3ODS8L_X9od1oVpsEq0zDypdu7q3IJuNd-PPLp3RPBpE9twgj_XOB1MG0o1xoz9_u3go2qGDzgkAj3KBcmXqnsWr3Tfr4Jug2CQ0V-C3H-H2NzwtXsOIbUppXmg9p3-iPc5UfKMsUluFI0qv2_09bluRGQcUrUWpFQbab8rxn_1gEFopvGTNFApQuzXuKT8KD726-GvldpuZ8mjCn00rlYI6JliTTJd-2CXQcnTmjBO0c0NSeM2jr_bKsMBtvCevbLepJvm0zXLIHCZU9qwTKCqAswaXt7ox7yApJTWXBPjF=w700-h394-no)

Простейшими граничными условиями являются числовые… Любой аспект работы программы, к которому применимы понятия больше или меньше, раньше или позже, первый или последний, короче или длиннее, обязательно должен быть проверен на границах диапазона… на границах порой случаются самые неожиданные отклонения...

Для каждого класса эквивалентности достаточно провести один-два теста. И лучшими из них будут те, которые проверяют значения, лежащие на границах класса...

О вопросах, освещаемых в этой главе, подробно рассказывается у Майерса (Myers, 1979) — особенно хорошо он пишет о классах и граничных условиях...

Необходимо протестировать каждую границу класса эквивалентности, причем с обеих сторон… Вот ряд примеров…

- Если допустимые значения от 1 до 99, для тестирования допустимых данных можно выбрать 1 и 99, а для тестирования недопустимых 0 и 100.
- Если программа выписывает чеки на суммы от `$1` до` $99`, то стоит попробовать выписать чек на отрицательную сумму, на `$0`, на `$100`.
- Если программа рисует линии длиной от одной точки до 4 сантиметров, нарисуйте одну точку и линию длиной ровно 4 сантиметра. Пусть программа также попробует нарисовать линию нулевой длины.
- Если сумма входных значений должна равняться 180, попробуйте ввести значения, дающие в сумме 180, 179 и 181.
- Если программа ожидает заглавную английскую букву, введите A и Z. Проверьте также символ `@`, поскольку его код предшествует коду символа A, и символ `]`, код которого следует за кодом символа Z. Кроме того, проверьте символы a и z.
- Если программа получает определенное количество входных данных, попробуйте ввести в точности необходимое количество, на единицу меньшее и на единицу большее.
- Если программа принимает ответы B, C и D, попробуйте ввести A и E.
- Попробуйте отправить на печать файл непосредственно перед и сразу после того, как принтер напечатает еще чье-либо задание.
- После чтения и записи файла на диск проверьте его первый и последний символы.

![Канер, рисунок 12.17](https://lh3.googleusercontent.com/gi_WeuBdJPBqzghnX-3y8OXhlP_vwwPboEuM89farx1_QUK9a4LnTeMibvkajg-mwNMMGrH21tyeyMOwSS2zx5RsMgjS6-V9fvbwII0zwD7oeeUun-5pKr-u2B4tH5kBUi2XoAaqUqUhyb1B5_K29VWVeVlal4tteMI7RTvLYbTixyJjLMg3XivZ4td7mQednD56Q0I-burngtkQTQD5s5DJWPh4vuYnQwq8Nd-mwZ3-3I2EosECbtHGkDuYLwaBW4dkSOmg5qry3_610yCn8oiVDHRag9o0wD1OCVJ-xXC6a0HvniYVIwXJ_yo4BKkw5FflAsINzJRju4Evn8d1l0-hqNmmVBobOgMtKTIc9TZ28B-5U8N9qQDig3cqyMOUy51TaGS50yiTwdx1J72MfNHxloBgolNF16sBe3tHYX2EpR05PwruncqNaMYmtjSlsSsHVIWHMULN5qPn-tRTNIrJHOzzJ4QBdY56DoSavPmo5moCC5vq7F-pwzmbr4wRy2p-Lk86h3JFkMPLyLe2afr2kIiRH1LxdLUhl-5hzA7brKFudkSVToJ5CmolsuxT8VFmvMX-uHeYIPRqJLt4K8N6QukpHGiyxbBY9usAiQVt1ZGKpYXqrtsdDGakAsrQiCpyqClZcN7anqeZbT68u5kqytFG8TBZ=w578-h817-no)

Анализируя границы диапазонов значений, очень важно учесть все возможные выходные данные. Проанализируйте каждый элемент распечатки или изображения на экране. Каковы допустимые перечни или максимальные и минимальные значения каждого печатаемого параметра? Можно ли заставить программу сформировать данные, выходящие за эти границы и как это сделать?

### «Lessons Learned in Software Testing: A Context-Driven Approach», Сэм Канер, Джеймс Маркус Бах, Брет Петтичорд <a name="kbp"></a>

Издательство Wiley. Перевод Максима Захарова, 2001 год:

![James Marcus Bach](https://lh3.googleusercontent.com/K_XVAK7U1dlF9YhjoeycliutIJnOz9055S9FiB82cD1RsFWoow3aMaMNB0uPPRr0bFS4A6qhR99uSba6LxpkP1b179GV_y_BkkjFm3ceA_hRj44UPcp7xTHTJvHGQt57hsZRtLTLl5bm4k-YG5R5_teCH84Akhht9cDY6S89Q2atbZ-77PtM0lMjcWmhpOPmrdiTJ-1NWMv5TdH_fg3bTHRRm8X-lGl4kyOpzU58nL_QYeJF2OPJu_1cohtJ1aNe9XYG02yAFHq8Le76KkV1k4a9SXxKdbx99UvpwBX9xVZDfbDUGUTDaC_gPGNYdB7TYxvGeRb3bGZMTVHG_h0yujvQuwI3p-TI6wDYVpqs5hKPMHZ7G0gj9PK9Z2V4lOxXokpsH1Fct3dlaXJIGY1t_pFuXthwV6yGbwGLqBZBkLPX0CgTwaTv0lE7sZL3D8J5ecS8jKmapvq8H6WoQwprzrGGY3b6D4cuBEVEYRX0Xf8L5_b82BQJkBLnGcaPnMwcWK6zDaOVo0ceglOn6gZTosrFuzzC3ig3cq6N8-rgk6-SIuv7A0BBSW0n12vi24tLKpvgv_mX49IgyZv_NaTApzx7tnvHsMR6DwjbVDCD2ZLQNwFyfJBOM2Hx7JahkeLSKd4as02Kyfqg26wBc7ajsc3WZb5B6iJB=w1072-h603-no)

**Тестирование граничных значений**

Класс эквивалентности - это набор переменных. Если вы можете отразить их на числовой оси, то граничными значениями будут наибольшие и наименьшие значения класса. В тестировании граничных значений вы тестируете их, а также те граничные значения близлежащих классов, которые лишь ненамного меньше, чем наименьшее значение вашего класса и ненамного больше, чем наибольшее значение вашего класса. Рассмотрим поле ввода, принимающее целые значения от 10 до 50. Значения, представляющие интерес, это: 10 (меньшее значение), 9 (наибольшее неподходящее значение), 50 (наибольшее), 51 (наименьшее неподходящее).

### "Быстрое тестирование", Роберт Калбертсон, Крис Браун, Гэри Кобб

Издательский дом "Вильямс", 2002 год. 75, 108-109, 214-215 страница:

**Анализ граничных значений**

Анализ граничных значений представляет собой технологию проектирования тестов, которая является дополнением разбиения на классы эквивалентности. Вместо того чтобы выбирать некоторый конкретный элемент класса эквивалентности, анализ граничных значений предлагает проектировщику теста выбрать элементы, которые находятся "на границе" класса. Экспериментально было доказано, что дефекты имеют тенденцию концентрироваться на границе области ввода, а не в ее центре. Не особенно ясно, почему так получается, это всего лишь установленный факт.

Например, в случае программы, которая для почтового индекса и веса отправляемого груза вычисляет стоимость доставки, анализ граничных значений позволяет применять в качестве тестовых значений минимальное и максимальное значение веса (1 унция и 100 унций), а также ближайшее значение, меньшее минимально допустимого (0 унций), и ближайшее значение, большее максимально допустимого (101 унция). Эти значения позволяют проверить границы диапазона допустимых значений, а также значения, выходящие за пределы этого диапазона. Более подробную информацию по анализу граничных значений можно найти в главе 10 "Технологии динамического тестирования и советы", а также в

- Myers, Glen. (1979). The Art of Software Testing. New York: Wiley.
- Kaner, Cem, Jack Falk, and Hung Quoc Nguyen. (1999). Testing Computer Software (2nd ed.). New York: Wiley.
- Pressman, Roger. (1997). Software Engineering: A Practitioner's Approach (4th ed.). New York: McGraw-Hill.
- Fewster, Mark, and Dorothy Graham. (1999). Software Test Automation. Reading, MA: Addison-Wesley.

**Анализ граничных значений**

Весьма перспективной областью для поиска ошибок являются границы классов эквивалентности функции. Как правило, анализ, который ведет к определению классов эквивалентности, определяет и эти границы. Включение нескольких пограничных значений в тестовые случаи для данной функции поможет проверить удовлетворение ожиданий (требований) пользователя. Кратко рассмотрим причины ошибок разработчиков при кодировании граничных значений. Причины появления в программных продуктах ошибок, связанных с граничными значениями, достаточно легко понять, анализируя количество преобразований, которые выполняются с момента разработки требований до момента начала динамического тестирования. Прежде всего, все требования создаются на высоком уровне. Они содержат не слишком много подробностей. Как правило, на этапе рабочего проектирования (РП) проектировщики программного обеспечения добавляют в RTM так называемые производные требования, преобразуя исходные требования в подробные и точные с точки зрения вычислений.

В организациях, занимающихся быстрым тестированием, уже осознали важность этапа РП для команды тестирования. Если производные требования отсутствуют или разработаны неправильно, то персоналу, занятому кодированием или тестированием, в ходе планирования, соответственно, придется дополнять высокоуровневый проект архитектуры и исходные требования этими документально оформленными подробностями рабочего проекта, в том числе и определяющими поведение программы на границах классов эквивалентности. В качестве примера рассмотрим конструкции IF. По прошествии ряда лет многие исследователи в области компьютерных наук отметили, что утверждения в конструкции IF — это те программные элементы, в которых ошибки встречаются наиболее часто. Решение об использовании условия "меньше чем" или "меньше или равно" в утвердительной части конструкции IF часто принимается на этапе РП. В противном случае отсутствие этих спецификаций должно быть выявлено во время инспекций, выполняемых на этапе РП.

### «Тестирование Дот Ком, или Пособие по жестокому обращению с багами в интернет-стартапах», Роман Савин <a name="savin"></a>

Москва, Дело, 2007 год. 195-202 страницы:

![Тестирование дот ком](https://lh3.googleusercontent.com/MZgDzxLlytmOe9ehXXnAB_HBABVdOtW0Eeyuz-TylFxRbktRXfBfJajoo7GUwuoIes_VBIRWxvuXgAYMo0NVtnzgtzP7EZ29033GasQJZ0nZ3pyNklGk90HXU0yYRbeIcFfLbCmq5_fgCdbU9S8ASUP0PUVZu6ZQCJwflnWuvH0lHrKSZ-ta2Z9oB69zIeIOzXCtkbTbHtO-x-lKmmjnHdSmTtQxvBm-_lASpsbtAAfrIrwgB24597C9nbNJYVmtYz5cCFoFqQ1a2UxzquIi1sB60zIK_gAXRvpSApHzHrgn03GZ6vrW8F_9ZG5VbxpO5Nin4QUbgFmCtVrUV6SNywJ63E96kY5Iw5YJdRm0cIAqmq9Mmm_AHqWk8taeFhw_N713apkDXi2rS44fRVUmKSZdwLA3n8Mo6lPDJ7dDrHd4cdgQ7EubsASMdPzm2HabZvR1CnrRwRHfhX4rgUKauKE2c1KmizGcR23ZxCR5Imy_ZE4QWPXyeh9VtCBC75D4J1drOBDJt7EQ1feEKvDDzrUUUnRk60d1VwUFM2teGbat_GX6kvpdWfv8ha8lgpNU0XIII637xALxgc_xRCFapPaF7jZ5Y3dfTESYb-6qSljvTe2aE1mLK15FI42BEWwO5gOJVQHwUV1Zoj1-c8uFt-4BW9ZfZyfn=s816-no)

**Пограничные значения (boundary values)**

Все очень просто. Давайте представим себе наши эквивалентные классы из предыдущего примера:

![](https://lh3.googleusercontent.com/52Uj5zeF5SU7EjZgMnH3s4RPQ0qanBsNa3RE9RFf67D2nS0l9GGpgH50GK7tAOPO7kJoVAhhgka43jEG1w_AqkLcuASx7zLoon7LNCiiV9pIokaCvpA-cIkbTJPKOjNecy_fhJ9gKxY9_5PMYh_9NvN4zJFs1leigdTXH2ssnB0QA_RKk4Rfuxd850ARKud_gQaKDPwWjZgwqVWrKEE_n6ZGebAfXuTGYitWmGia2kk_iQK6AKMGV2q0Z2wN6BaUIbNbh07fMoMpK-8s6iCsVtenKHfGn4jdOdYvxIowlX7P8Y_K0bdsq7FiG4m8moRilgtV5L2hKw5DoQzreGpF2zYZGC6r2fsaCjLJ5dzsf831qfOqKIkQybGaxVb6O8mo6Bhz2gSmctheGQ3xmqgs4pIxv1sVYycM-ROng4JhTjz7eFsE6Svz_86Cf1jI7cu6mFtegUfyu08ByVQHIUPQGGd-VCx8WYP1ogTjNYq-2aOczNd8CICBjO7k_UIBRe-fF45QMrwBSNLUaPpteOmaUsJU8QGKPwJ2PsBMGUU0RzunWsmXSylI9cAPVzo2G-Kw5a0KuxdQviUbJpr8iIYtVgiLgZv0H5F6NZgaE2VQwxHboVBe-X49P8dIoRuUItpbPBBpsS3i2pJFLk0zFX-uxh8vc-inDSmi=w853-h378-no)

Вертикальная пунктирная линия — это первое возможное значение класса (нижний предел). Вертикальная сплошная линия — это последнее возможное значение класса (верхний предел).

Пограничные значения — это конкретные предельные значения, образующие водораздел между эквивалентными классами.

Для каждого эквивалентного класса может быть лишь один из трех вариантов:
- а. Есть только нижний предел (класс 5).
- б. Есть нижний и верхний пределы (класс 2, класс 3, класс 4).
- в. Есть только верхний предел (не рассматриваемый в данном примере класс, который ограничен только сверху гипотети ческим отрицательным значением, непосредственно пред шествующим классу 1).

Пограничным тестированием (boundary testing) называется применение метода тестирования пограничных значений.

Вот полная версия метода тестирования пограничных значений.
- а. Сначала тестируется нижний предел данного класса (если он имеется).
- б. Затем тестируется верхний предел данного класса (если он имеется).
- в. Затем тестируется любое значение внутри данного класса.
- г. Затем тестируется верхний предел класса, непосредственно предшествующего данному классу (если предшествующий класс имеется).
- д. Затем тестируется нижний предел класса, непосредственно следующего за данным классом (если следующий класс имеется).

а, б, в являются позитивными тестами, г и д — негативными тестами.

Давайте же возьмем и протестируем эквивалентный класс 2. Суть тестирования заключается в том, чтобы удостовериться, что для покупок от 200,00 до 499,99 руб. (включительно) будет дана скидка 2%. Опустим шаги сценариев и поговорим только о данных для них. Следуем методике тестирования эквивалентного класса, нам нужно лишь пять вариантов данных:

- а. 200,00;
- б. 499,99;
- в. 315,11;
- г. 199,99;
- д. 500,00.

Почему нам хватило только 5 сценариев, мы поговорим через минуту.

А сейчас давайте посмотрим, сколько возможных вариантов только для позитивных тестов у нас потенциально есть для класса 2: 30 000 (по количеству копеек в 299,99 руб. плюс один случай, когда потрачено 200,00 руб.).

Наша методика позволила обойтись лишь 3 тестами (позитивные тесты: а, б, в), которыми мы по сути протестировали 30 000 значений. По-моему, выглядит впечатляюще.

Теперь о 5 сценариях, которых было достаточно для позитивного и негативного тестирования класса 2.

Представим себе схематично логику кода для решения вопроса о скидке для класса 2:
```
ЕСЛИ сумма > 200,00 И сумма < 499,99,
ТО скидка = сумма /100 х 2.
```

Теперь рассмотрим, как каждый из наших тест-кейсов точечно бьет по возможным проблемам кода. Прошу особого внимания — ничего сложного нет, но много нюансов.

| Тест-кейс  | Код с выделенной жирным шрифтом частью, которая проверяется данным тестом  | Возможная проблема кода, разоблачаемая тестом, и пример проблемы  | Ожидаемый результат  |
|---|---|---|---|
| а. Сначала тестируется нижний предел данного класса (если нижний предел имеется): 200  | ```ЕСЛИ сумма > **200,00** И сумма < 499,99, ТО скидка = сумма/100 х 2```  | Ошибка в знаке равенства и/или сумме нижнего предела. _Пример (знакравенства перед 200,00 пропущен): ```ЕСЛИ сумма > 200,00 И сумма < 499,99, ТО скидка = сумма/100 х 2```_  | 2% от 200  |
| б. Затем тестируется верхний предел данного класса (если верхний предел имеется): 499,99  | ```ЕСЛИ сумма > 200,00 И сумма < **499,99**, ТО скидка = сумма/100 х 2```  | Ошибка в знаке равенства и/или сумме верхнего предела. _Пример (**499,00** вместо 499,99): ```ЕСЛИ сумма > 200,00 И CVMMQ < 499,00, ТО скидка = сумма/100 х2```_  | 2% от 499,99  |
| в. Затем тестируется любое значение внутри данного класса: 315,11  | ```ЕСЛИ сумма > **200,00** И сумма < **499,99**, ТО скидка = сумма/100 х 2```  | Ошибка в знаках больше (>) и меньше (<). _Пример (больше вместо меньше и меньше вместо больше): ```ЕСЛИ сумма < 200,00 И сумма > 499,00: ТО скидка = сумма/100 х 2```_  | 2% от 315,11  |
| г. Затем тестируется верхний предел класса, непосредственно предшествующего данному классу (если предшествующий класс имеется): 199,99  | ```ЕСЛИ сумма > **200,00** И сумма < 499,99, ТО скидка = сумма/100 х 2```  | Тонкий момент. Здесь мы проверяем две вещи: 1. Наличие скачка от верхнего предела предьщущего класса к нижнему пределу нашего класса. Это делается для следующей ситуации. Допустим, программист напечатал 100,00 вместо 200,00: ```ЕСЛИ сумма > 100,00 И сумма < 499,99, ТО скидка = сумма/100 х 2```. Если сделана такая ошибка, то она не будет обнаружена ни тестом а, ни тестом б, ни тестом е. 2. Логическое "И", так как если бы у нас было "ИЛИ": ```ЕСЛИ сумма > 200,00 ИЛИ сумма < 499,99, ТО скидка = сумма/100 х 2```, то к данному классу принадлежало бы любое в принципе возможное значение  | Скидка **не равна** 2% от 199,99  |
| д. Затем тестируется нижний предел класса, непосредственно следующего за данным классом (если следующий класс имеется): 500,00  | ```ЕСЛИ сумма > 200,00 И сумма < 499,99, ТО скидка = сумма/100 х 2```  | 1. Наличие скачка от верхнего предела нашего класса к нижнему пределу следующего за ним класса. Это делается для следующей ситуации. Допустим, программист напечатал 599,99 вместо 499,99: ```ЕСЛИ сумма > 200 И сумма < 599,99, ТО скидка = сумма/100 х 2```. Если сделана такая ошибка, то она не будет обнаружена ни тестом а, ни тестом б, ни тестом в, ни тестом г. 2. Проверяется логическое "И", так как если бы у нас было "ИЛИ": ```ЕСЛИ сумма > 200,00 ИЛИ сумма < 499,99, ТО скидка = сумма/100 х 2```, то к данному классу принадлежало бы любое в принципе возможное значение  |  Скидка не равна 2% от 500,0  |

Замечу, что для удобства в понимании мы производили тестирование класса 2 **изолированно** от его собратьев.

И теперь, поняв и разобравшись, давайте рассмотрим, как нам протестировать все эквивалентные классы данного спека:

| Класс  | Значение  | Ожидаемая ставка скидки, %  |
|---|---|---|
| Класс 1  | 0<br>100,00<br>199,99  | 0  |
| Класс 2  | 200,00<br>315,11<br>499,99  | 2  |
| Класс 3  | 500,00<br>659,23<br>999,99  | 3  |
| Класс 4  | 1000,00<br>3265,26<br>4999,99  | 4  |
| Класс 5  | 5000,00<br>5075,00  | 5  |

Итого 14 тест-кейсов для тестирования всех возможных значений. Неплохо. Очень даже неплохо!

На сером фоне 5 значений ввода, которые мы использовачи для изолированного тестирования нашего любимого класса 2. Прошу отметить следующую вещь: теперь, когда мы тестируем класс 2 вместе с окружающими его собратьями, для класса 2 достаточно 3 тест-кейсов, так как случаи г. (199,99) и д. (500,00) покрываются при тестировании класса 1 и класса 3 соответственно.

Мы рассмотрели самый сложный вариант пограничного тестирования, когда мы проверяли эквивалентные классы, включающие множества значений. Зато теперь, пройдя огонь, воду и медные трубы, нам ничего не стоит разобраться в более простом случае, когда эквивалентный класс содержит только одно значение.

_**Пример**_

Возьмем индекс, который должен быть равен 6 цифрам (Индекс_эл 005 из табл. 1, матричной раскладки поля "Индекс"). Применяем метод тестирования пограничных значений:

- а. 6
- б. 6
- в. 6
- г. 5
- д. 7

Таким образом, у нас есть:

- один позитивный тест 6 и
- два негативных теста 5 и 7.

Мы применяем метод

- как обособленно (тестирование скидок),
так и
- в сочетании с другими методами генерирования и отбора тестов (использование пограничных значений на матрич ной раскладке поля "Индекс").

Идея о возможности обособленного или интегрированного применения, конечно, относится к каждому из методов генерирования и отбора тестов.

Это все о пограничном тестировании.

Важная мысль перед списком изученных нами вещей о подготовке к тестированию:

Не методы должны управлять вашей подготовкой, а вы должны управлять методами так, чтобы с их помощью создать именно те тест-кейсы, которые с высокой вероятностью могли бы найти баги. Для этого нужно в совершенстве владеть каждым из методов. И только практика может отточить ваши навыки. Практикуйтесь и помните о примере с шахматами, которым мы поставили себе мозги в начале нашей сегодняшней беседы.

04.09.2016. Перейти на [Главную страницу](./)
