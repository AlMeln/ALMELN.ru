# Классы эквивалентности

В [учебных программах](/2016-08-14-educational-programs-exam-questions-and-literature.md) по дисциплине "Обеспечение качества и тестирование программ" есть тема для изучения - "Техники тестирования. Метод эквивалентных классов и граничных значений".

В программе обучения базового уровня International Software Testing Qualifications Board "Сертифицированный тестировщик" указано на необходимость:

- Создать тестовые сценарии для приведенных моделей программного обеспечения при помощи следующих методов проектирования тестов: (1) эквивалентное разбиение; (2) анализ граничных значений; (3) тестирование таблицы решений; (4) тестирование таблицы переходов.
- Объяснить назначение каждого из четырех методов, какие уровни и типы тестирования могут использовать данные методы, и каким образом может быть измерено покрытие при использовании данных методов.

Содержание:

1. [«Искусство тестирования программ», Глендфорд Майерс](#mayers)
2. [«Тестирование программного обеспечения. Фундаментальные концепции менеджмента бизнес-приложений», Сэм Канер, Джек Фолк и Енг Кек Нгуен](#kaner)
3. [«Тестирование черного ящика. Технологии функционального тестирования программного обеспечения систем», Борис Бейзер](#beizer)
4. [«Тестирование Дот Ком, или Пособие по жестокому обращению с багами в интернет-стартапах», Роман Савин](#savin)
5. [«Тестирование программного обеспечения. Базовый курс», Святослав Куликов](#kulikov)

### "Искусство тестирования программ", Глендфорд Майерс <a name="mayers"></a>

Москва, Финансы и статистика, 1982 год. 63-74 страницы:

![](https://lh3.googleusercontent.com/Gmy5jdSIegZpdYaGGxHyIho9PL2tqBhARRwK5AM3N0C6iB8fYKwKauRl4tU6mYJ3M9U_r7P_s2vK0cOr0QeS1JkG14ZDS1Mi1hvbLSN9kxpAd65mC4wamY95gD_AZ4zsxE8xzqqKcy02eIEagXp8zPXI2wXxVJLD4PnBHJnySzgmHMW9aC19K52-SEguP7URvxcZUlP6INuhq4fnyuWKGDgkZJL9M5GrJul7fWwedWEKlVEzE4qmutEfGBbaGDkQMY9O6NeQhO2A31VKvix6u2yN4j8zonYNJ9AgyFn3e1Ev1e_-n9H5THjqKoRCm9uWkYpk4sfymWQWuVrjhijfTzrqZIq5yUnIfiU-jXwIgvRb9OGjGY0S0PWw2keMoXB1ZZQS_9Fybt9atzml6cfoUmMOVdqS1MbkD1PA6aYxWlwYUW0t6pyevum4JMkGv2IL6PFADrM5mh9BSkLNr_TDMK1aHrolYqmkKRWK4dFTzKPbyPsWmXqfH7ageaP5a40kVHNhewSql55yrRqFPEJmIRaOQw0ainfE6xQirz3F-Kbb_Mc1cNyrjU3vtha5WQkDUgp6T5y08-X40eWVEMQRyn-iO9LCWmoAbLe1I_AwzLumtJPKpHMG3o9oaNUFaDfO7ZDoVzkcOw7utPPzRR8KhbbodVqG631C=s579-no)

**Эквивалентное разбиение**

В главе 2 отмечалось, что хороший тест имеет приемлемую вероятность обнаружения ошибки и что исчервывающее входное тестирование программы невозможно. Следовательно, тестирование программы ограничивается использованием небольшого подмножества всех возможных входных данных. Тогда, конечно, хотелось бы выбрать для тестирования самое подходящее подмножество (то есть подмножество с наивысшей вероятностью обнаружения большинства ошибок).

Правильно выбранный тест этого подмножества должен обладать двумя свойствами:

1. уменьшать, причем более чем на единицу, число других тестов, которые должны быть разработаны для достижения заранее определенной цели "приемлемого тестирования";
2. покрывать значительную часть других возможных тестов, что в некоторой степени свидетельствует о наличии или отсутствии ошибок до и после применения этого ограниченного множества значений входных данных.

Указанные свойства, несмотря на их кажущееся подобие, описывают два различных положения. Во-первых, каждый тест должен включать столько различных входных условий, сколько это возможно, с тем чтобы минимизировать общее число необходимых тестов. Во вторых, необходимо пытаться разбить входную область программы на конечное число _классов эквивалентности_ так, чтобы можно было предположить (конечно, не абсолютно уверенно), что каждый тест, являющийся представителем некоторого класса, эквивалентен любому другому тесту этого класса.

Иными словами, если один тест класса эквивалентности обнаруживают ошибку, то следует ожидать, что и все другие тесты этого класса эквивалентности будут обнаруживать ту же самую ошибку. Наоборот, если тест не обнаруживает ошибки, то следует ожидать, что ни один тест этого класса эквивалентности не будет обнаруживать ошибки (в том случае, когда некоторое подмножество класса эквивалентности не попадает в пределы любого другого класса эквивалентности, так как классы эквивалентности могут пересекаться).

Эти два положения составляют основу методологии тестирования по принципу чёрного ящика, известной как _эквивалентное разбиение_. Второе положение используется для разработки набора "интересных" условий, которые должны быть протестированная, а первое – для разработки минимального набора тестов, покрывающих эти условия.

Примером класса эквивалентности для программы о треугольнике (смотри главу 1) является набор "трёх равных чисел, имеющих целые значения, большие нуля". Определяя этот набор как класс эквивалентности, устанавливают, что если ошибка не обнаружена некоторым тестом данного набора, то маловероятно, что она будет обнаружена другим тестом набора. Иными словами, в этом случае время тестирования лучше затратить на что-нибудь другое (на тестирование других классов эквивалентности).

Разработка тестов методом эквивалентного разбиения осуществляется в два этапа:

1. выделение классов эквивалентности и
2. построение тестов.

**Выделение классов эквивалентности**

Классы эквивалентности выделяются путем выбора каждого входного условия (обычно это предложение или фраза в спецификации) и разбиением его на две или более групп. Для проведения этой операции используют таблицу, изображенную на рисунке 4.3. Заметим, что различают два типа классов эквивалентности: правильные классы эквивалентности, представляющие правильные входные данные программы, и неправильные классы эквивалентности, представляющие все другие возможные состояния условий (то есть ошибочные входные значения). Таким образом, придерживаются одного из принципов главы 2 о необходимости сосредоточивать внимание не неправильных или неожиданных условиях.

| Входные условия  | Правильные классы эквивалентности  | Неправильные классы эквивалентности  |
|---|---|---|
| ...  | ...  | ...  |

Если задаться входными или внешними условиями, то выделение классов эквивалентности представляет собой в значительной степени эвристический процесс (под эвристикой понимают совокупность приёмов и методов, облегчающих и упрощающих решение познавательных, конструктивных, практических задач). При этом существует ряд правил:

1. Если входное условие описывает _область_ значений (например, "целое данное может принимать значения от 1 до 999"), то определяются один правильный класс эквивалентности (1 <= значение целого данного <= 999) и два неправильных (значение целого данного < 1 и значение целого данного > 999).
2. Если входное условие описывает _число_ значений (например, "в автомобиле могут ехать от одного до шести человек"), то определяются один правильный класс эквивалентности и два неправильных (ни одного и более шести человек).
3. Если входное условие описывает *множество* входных значений и есть основание полагать, что каждое значение программа трактует особо (например, "известны способы передвижения на АВТОБУСЕ, ГРУЗОВИКЕ, ТАКСИ, ПЕШКОМ или МОТОЦИКЛЕ"), то определяется правильный класс эквивалентности для каждого значения и один неправильный класс эквивалентности (например, "НА ПРИЦЕПЕ").
4. Если входное условие описывает ситуацию "должно быть" (например, "первым символом идентификатора должна быть буква), то определяется один правильный класс эквивалентности (первый символ – буква) и один неправильный (первый символ – не буква).
5. Если есть любое основание считать, что различные элементы класса эквивалентности трактуются программой неодинаково, то данный класс эквивалентности разбивается на меньшие классы эквивалентности.
Этот процесс ниже будет кратко проиллюстрирован.

**Построение тестов**

Второй шаг заключается в использовании классов эквивалентности для построения тестов. Этот процесс включает в себя:

1. Назначение каждому классу эквивалентности уникального номера.
2. Проектирование новых тестов, каждый из которых покрывает как можно большее число непокрытых правильных классов эквивалентности, до тех пор пока все правильные класс эквивалентности не будут покрыты (только не общими) тестами.
3. Запись тестов, каждый из которых покрывает один и только один из непокрытых неправильных классов эквивалентности, до тех пор пока всех неправильные классы эквивалентности не будут покрыты тестами.

Причина покрытия неправильных классов эквивалентности индивидуальными тестами состоит в том, что определённые проверки с ошибочными входами скрывают или заменяют другие проверки с ошибочными входами.

Например спецификация устанавливает "тип книги при поиске (ВЫЧИСЛИТЕЛЬНАЯ ТЕХНИКА, ПРОГРАММИРОВАНИЕ или ОБЩИЙ") и количество (1-9999)". Тогда тест
```
XYZ 0
```
отображает два ошибочных условия (неправильный тип книги и количество) и, вероятно, не будет осуществлять проверку количества, так как программа может ответить: "XYZ - НЕСУЩЕСТВУЮЩИЙ ТИП КНИГИ" и не проверять остальную часть входных данных.

Пример

Предположим, что при разработке компилятора для подмножества языка Фортран требуется протестировать синтаксическую проверку оператора DIMENSION. Спецификация приведена ниже. (Этот оператор не является полным оператором DIMENSION Фортрана; спецификация была значительно сокращена, что позволило сделать ее "учебным примером". Не следует думать, что тестирование реальных программ так же легко, как в примерах данной книги.) В спецификации элементы, написанные латинскими буквами, обозначают синтаксические единицы, которые в реальных операторах должны быть заменены соответствующими значениями, в квадратные скобки заключены необязательные элементы, многоточие показыает, что предшествующий ему элемент может быть повторен подряд несколько раз.

Оператор DIMENSION используется для определения массивов. Форма оператора DIMENSION:
```
DIMENSION ad[,ad]...
```
где `ad` есть описатель массива в форме

```
n(d[,d]...)
```

`n` - символическое имя массива, а `d` - индекс массива. Символические имена могут содержать от одного до шести символов - букв или цифр, причем первой должна быть буква. Допускается от одного до семи индексов. Форма индекса
```
[lb:]ub
```
где `lb` и `ub` задают нижнюю и верхнюю границы индекса массива.

Граница может быть либо константой, принимающей значения от -65534 до 65535, либо целой переменной (без индексов). Если `lb` не определена, то предполагаетя, что она равна единице. Значение `ub` должно быть больше или равно `lb`. Если `lb` опрееделена, то она может иметь отрицательное, нулевое или положительное значение. Как и все операторы, оператор DIMENSION может быть продолжен на нескольких строках. (Конец спецификации.)

Первый шаг заключается в том, чтобы идентифицировать входные условия и по ним определить классы эквивалентности (таблица 4.1). Классы эквивалентности в таблице обозначены числами.

| Входные условия  | Правильные классы эквивалентности  | Неправильные классы эквивалентности  |
|---|---|---|
| Число описателей массивов  | один (1), ```>``` одного (2)  | ни одного (3)  |
| Длина имени массива  | 1-6 (4)  | 0 (5), ```>``` 6 (6)  |
| Имя массива  | имеет в своем составе буквы (7) и цифры (8)  | содержит что-то еще (9)  |
| Имя массива начинается с буквы  | да (10)  | нет (11)  |
| Число индексов  | 1-7 (12)  | 0 (13), ```>``` 7 (14) |
| Верхняя граница  | константа (15), целая переменная (16)  | имя элемента массива (17), что-то иное (18)  |
| Имя целой переменной  | имеет в своем составе буквы (19), и цифры (20)  | состоит из чего-то еще (21)  |
| Целая переменная начинается с буквы  | да (22)  | нет (23)  |
| Константа  | -65534-65535 (24)  | `< -65534` (25), `> 65535` (26) |
| Нижняя граница определена  | да (27), нет (28)  |   |
| Верхняя граница по отношению к нижней границе  | больше (29), равна (30)  | меньше (31)  |
| Значение нижней границы  | отрицательное (32), нуль (33), > 0 (34)  |   |
| Нижняя граница  | константа (35), целая переменная (36)  | имя элемента массива (37), что-то иное (38)  |
| Оператор расположен на нескольких строках  | да (39), нет (40)  |   |

Следующий шаг - построение теста, покрывающего один или более правильных классов эквивалентности. Например, тест
```
DIMENSION A(2)
```
покрывает классы 1, 4, 7, 10, 12, 15, 24, 28, 29 и 40.  Далее определяются один или более тестов, покрывающих оставшиеся правильные классы эквивалентности. Так, тест
```
DIMENSION A12345(I,9,J4XXXX,65535,1,KLM, X 100), BBB (-65534:100,0:1000,10:10,1:65535)
```
покрывает оставшиеся классы. Перечислим неправильные классы эквивалентности и соответствующие им тесты:
```
(3): DIMENSION
(5): DIMENSION (10)
(6): DIMENSION A234567(2)
(9): DIMENSION A.1(2)
(11): DIMENSION 1A(10)
(13): DIMENSION B
(14): DIMENSION B(4,4,4,4,4,4,4,4)
(17): DIMENSION B(4,A(2))
(18): DIMENSION B(4,,7)
(21): DIMENSION C(I.,10)
(23): DIMENSION C(10,1J)
(25): DIMENSION D(-65535:1)
(26): DIMENSION D(65536)
(31): DIMENSION D(4:3)
(37): DIMENSION D(A(2):4)
(38): DIMENSION D(.:4)
```
Эти классы эквивалентности покрываются 18 тестами. Читатель может при желании сравнить данные тесты с набором тестов, полученным каким-либо специальным методом.

Хотя эквивалентное разбиение значительно лучше случайного выбора тестов, оно все же имеет недостатки (то есть пропускает определенные типы высокоэффективных тестов). Следующие два метода - анализ граничных значений и использование функциональных диаграмм (диаграмм причинно-следственных связей cause-effect graphing) - свободны от многих недостатков, присущих эквивалентному разбиению.

### «Тестирование программного обеспечения. Фундаментальные концепции менеджмента бизнес-приложений», Сэм Канер, Джек Фолк и Енг Кек Нгуен <a name="kaner"></a>

Москва, ДиаСофт, 2001. 97, 181, 191-192 страницы:
![](https://lh3.googleusercontent.com/dpeO6RBu2RD1ESmNDXwJkn2uNbXdsERTX4JSxXdZi6CmOjSC7r01qkH5LO0Q2Xv4-nXbr9ufKeBx5LNxdNmRYqEjgbEho3OdWyT3O0eAgT91h7tkX9wTeAaMpNRy8anRcrCPjhj7jsVTRClgg_PAL45f_7ftp_q7aCgAk-l0ZDDv2ztyloIs0WXZffAYa0BkvyZxae0QlbZYdmbdNTxkQGfdLFk-KayofnGglbmslW4ADZjEDWxxjMclA834-hhj1D8AF-3zQNt3wlUl00IqTvuo-QJI7jtYtdhnSDtAP1dkPyl_1xqYkBm8XJmdaJVmcpJJ5ebPcuI35Y58_pxfmcBqNRcraupPG5Diqk86JTtFGdMB2Ngw3ODS8L_X9od1oVpsEq0zDypdu7q3IJuNd-PPLp3RPBpE9twgj_XOB1MG0o1xoz9_u3go2qGDzgkAj3KBcmXqnsWr3Tfr4Jug2CQ0V-C3H-H2NzwtXsOIbUppXmg9p3-iPc5UfKMsUluFI0qv2_09bluRGQcUrUWpFQbab8rxn_1gEFopvGTNFApQuzXuKT8KD726-GvldpuZ8mjCn00rlYI6JliTTJd-2CXQcnTmjBO0c0NSeM2jr_bKsMBtvCevbLepJvm0zXLIHCZU9qwTKCqAswaXt7ox7yApJTWXBPjF=w700-h394-no)

Простейшими граничными условиями являются числовые… Любой аспект работы программы, к которому применимы понятия больше или меньше, раньше или позже, первый или последний, короче или длиннее, обязательно должен быть проверен на границах диапазона… на границах порой случаются самые неожиданные отклонения...

Весь продукт тестировать не нужно, достаточно выбрать пять полей ввода данных — они обычно имеются в любой программе… Для каждого поля ввода данных выполните следующее:

1. Проанализируйте значения, которые в него можно вводить. Сгруппируйте их в классы.
2. Проанализируйте возможные граничные условия. Их можно описать, исходя из определений классов, но возможно, что в ходе этого анализа добавятся и новые классы значений.
3. Нарисуйте таблицу, в которой перечислите все классы значений для каждого поля ввода и все интересные тестовые примеры (граничные и другие особые значения). Пример такой таблицы приведен на рисунке 7.1. Если у вас будет плохо получаться, прочитайте раздел главы 12 «Таблицы граничных значений».
![Канер, рисунок 7.1](https://lh3.googleusercontent.com/dqdAhl2Nsc4YLTE62aLQvvcNU_P-3vl0Kci6WpCh_BKJ3aSVvP4VsjJiDRPxisJCNNy-rOXLREquZdNbugy-tSMONQB4YVZAeCH8BpkKgDVhLnq_ycv_LuagwK5typvH6n2daHaEtUSI02uYNpq6rO5E9t4QhLcQT70AtyW2AN0Iob_00XnXuORBkIeCvSXcf8pKVxF-7A0BDAqSycR2GC-TCcv-bXpa1MnLW2VK1xu2E4mM1EJ1gXrymHKQ70C6_oO0DgcHBUO7xEB7RJWusveF7eTE-iNvjq5I6x-8IYAK9P5fwrRGXasf-SLaGNvtO-e8bW8cMEItnjLafGxq_faMudWtJdz6GY7z7KqnUiIQohd29Y-efr6A6_EYaVzCneddMLkfuPy7MI4dMkSUNF8S8iFgcbes3_hs6nYyqhWr7JvponyngyHX78j9-yvdMY9jbA98kAMyyrrV3NSqPBFpnjT4XaUCgl6PpJeg01N-Ju7FEM9nEfzgaS2u8bVFZC5xFqQ_HVtVs2mgpQU-dCKYVKArG1bkc3uMGV-RxJKL7tR_epAnG6roaEfZqeoATvi5vbmd2V86GahZv3z1Y2ciKHoFtgJMBFRb3aaGe-x6rVpCKKwui2IAsVYclm_qlVC4gjC9WPOzNmZSRZ1vDN4OKudbUHsK=w594-h544-no)
4. Протестируйте программу, используя записанные значения (а если их слишком много, то некоторое их подмножество). Протестировать программу, означает не только запустить ее, ввести данные и посмотреть, не произойдет ли сбой, — важно, чтобы программа правильно использовала введенные данные. Получаются ли, например, при печати указанные пользователем отступы? Обязательно продумайте тестовую процедуру, в которой программа использует введенную вами информацию

### "Быстрое тестирование", Роберт Калбертсон, Крис Браун, Гэри Кобб <a name="cbk"></a>

Издательский дом "Вильямс", 2002 год. 75, 108-109, 214-215 страница:

**Разбиение на классы эквивалентности**

Разбиение на классы эквивалентности представляет собой технологию проектирования тестов, ориентированную на снижение общего числа тестов, необходимых для подтверждения корректности функциональных возможностей программы. Основная идея, стоящая за разбиением на классы эквивалентности, заключается в том, чтобы разбить область ввода программы на классы данных. Если проектировать тесты для каждого класса данных, но не для каждого члена класса, то общее количество требуемых тестов уменьшается.

В качестве примера рассмотрим программу отображения почтовых индексов, которая рассматривалась ранее в главе. Предположим, что когда пользователь вводит пятизначный почтовый индекс и общую массу отправляемого груза в унциях, программа возвращает стоимость доставки пакета. Областью ввода для этой программы являются почтовые индексы и масса брутто отправляемого груза. Область ввода почтового кода может быть разбита на класс допустимых вводов и класс недопустимых вводов следующим образом:

- Допустимыми вводами являются все пятизначные наборы цифровых символов, образующих рабочий почтовый код
- Недопустимыми вводами являются:
	- Наборы цифровых символов, содержащие менее пяти символов
	- Наборы цифровых символов, содержащие более пяти символов
	- Наборы из пяти символов, не являющиеся рабочим почтовым кодом
	- Наборы из нецифровых символов.

Аналогичное разбиение может быть построено и для массы брутто отправляемого груза. Например, требуется программа, работающая только с грузами, масса которых находится в диапазоне от 1 до 100 унций. В этом случае числовые значения, попадающие в диапазон от 1 до 100, включая и конечные точки, являются допустимыми. Все значения меньше 1 и больше 100, отрицательные значения и нецифровые значения образуют недопустимые классы ввода.

Нужно спроектировать такие тесты, которые выполняют проверку, по меньшей мере, одного представителя каждого допустимого класса ввода и, по меньшей мере, одного представителя недопустимого класса ввода. В результате тестирования с применением допустимых вводов должны быть получены однозначно определенные и ожидаемые результаты. Для почтового кода 78723 и массы в 20 унций ожидается получить конкретное значение стоимости, и это значение должно быть определено в функциональных требованиях. В случае ввода недопустимых данных должно быть получено соответствующее сообщение об ошибке, если оно определено в технических требованиях и спецификациях. При вводе недопустимых данных программа, по меньшей мере, не должна завершаться аварийно, вызывать искажение данных или вести себя непредсказуемым образом.

Более подробное обсуждение разбиения на классы эквивалентности можно найти в главе 10 "Технологии динамического тестирования и советы", а также в:

- Myers, Glen. (1979). The Art of Software Testing. New York: Wiley.
- Kaner, Cem, Jack Falk, and Hung Quoc Nguyen. (1999). Testing Computer Software (2nd ed.). New York: Wiley.
- Pressman, Roger. (1997). Software Engineering: A Practitioner's Approach (4th ed.). New York: McGraw-Hill.
- Kit, Edward. (1995). Software Testing in the Real World: Improving the Process. Reading, MA: Addison-Wesley.
- Fewster, Mark, and Dorothy Graham. (1999). Software Test Automation. Reading, MA: Addison-Wesley.

**Разделение по классам эквивалентности**

Принадлежность двух элементов данных к одному и тому же классу эквивалентности просто означает, что с каждым из них функция выполняет одни и те же операции. Принадлежность двух элементов данных к различным классам эквивалентности означает, что существует, по меньшей мере, одна строка кода, требуемая для обработки одного элемента данных, которая не будет использоваться при обработке другого элемента данных. Часто данные, принадлежащие к одному из двух классов эквивалентности, называют правильными данными, а данные второго класса эквивалентности неправильными данными для данной функции. Ветви кода, которые используются для обработки правильных данных, называются удачными ветвями, в то время как ветви, выполняемые функцией при обработке неправильных данных, называются неудачными ветвями. В проектной документации для большинства функций определены правильные и неправильные входные данные. Для определения классов эквивалентности данных для каждой функции тестировщики должны прочесть проектную документацию. Если эта информация отсутствует в проектной документации, тестировщику придется применить функциональный анализ и восстановить информацию о классах эквивалентности снизу-вверх. В некоторых случаях в проектной документации может использоваться также термин допустимых и недопустимых данных для дайной функции. Операции тестирования во время ввода неправильных данных достаточно точно называются отрицательным тестированием. Неправильные данные выбираются с тем, чтобы убедиться в наличии в каждой функции обработчиков исключений, выполняющих обработку неправильных данных. Отрицательное тестирование не ограничивается одним лишь выполнением операций тестирования для случая неправильных данных (обратитесь к разделу, посвященному отрицательному тестированию, далее в этой главе).

Одна из принципиальных отличительных черт специалиста по тестированию, применяющего технологии быстрого тестирования, состоит в том, что при оценке вероятности наличия скрытых ошибок, которые могут препятствовать эффективному использованию конечной программы, он всегда учитывает широту и степень покрытия тестирования. Чтобы гарантировать тестирование как удачных, так и неудачных ветвей внутри каждой функции, тестировщик должен уделять пристальное внимание классам эквивалентности входных данных функций.

### «Тестирование черного ящика. Технологии функционального тестирования программного обеспечения систем», Борис Бейзер <a name="beizer"></a>

СПб: Питер, 2004, 55/321 страницы:

2.4.5. Классы эквивалентности и разбиения

Отношения эквивалентности - симметрично, транзитивно и рефлексивно. Набор объектов, удовлетворяющих отношению эквивалентности, называется классом эквивалентности. Каждый объект из этого класса называется эквивалентным (в смысле данного отношения) любому другому объекту этого класса.

Все методы, описываемые в этой книге, являются примерами тестирования путем разбиения:

- "Partition Testing Does Not Inspire Confidence", Hamlet R., Taylor R, 1988.
- "The Category-Partition Method for Specifying and Generating Fenctional Tests", Ostrand T.J., Baker M.J., 1998.
- "A Partition Analysis Method to Increase Program Reliability", Richardson D.J., Clarke L.A., 1981.
- "Approaches to Specification-Based Testing", Richardson D.J., 1989.
- "Intergration Testing", White Lee J., Leung Hareton K.N., 1994.

Эта стратегия построена на разбиении всех возможных входов на классы эквивалентности по какому-либо отношению эквивалентности. Я не буду в этой книге рассказывать, как создавать или находить подобные отношения, а познакомлю вас с набором уже готовых полезных отношений и, следовательно, полезных разбиений на классы эквивалентности.

Если у вас есть транзитивное отношение, то вы можете автоматически конвертировать его в соответствующее отношение эквивалентности и таким образом разбить множество вводов на классы эквивалентности. Однако этот метод не рассматривается в данной книге. Дополнительную информацию вы найдете в главе 12 "Software System Testing and Quality Assurance" Boris Beizer, 1990.

### «Тестирование Дот Ком, или Пособие по жестокому обращению с багами в интернет-стартапах», Роман Савин <a name="savin"></a>

Москва, Дело, 2007 год. 195-202 страницы:

![Тестирование дот ком](https://lh3.googleusercontent.com/MZgDzxLlytmOe9ehXXnAB_HBABVdOtW0Eeyuz-TylFxRbktRXfBfJajoo7GUwuoIes_VBIRWxvuXgAYMo0NVtnzgtzP7EZ29033GasQJZ0nZ3pyNklGk90HXU0yYRbeIcFfLbCmq5_fgCdbU9S8ASUP0PUVZu6ZQCJwflnWuvH0lHrKSZ-ta2Z9oB69zIeIOzXCtkbTbHtO-x-lKmmjnHdSmTtQxvBm-_lASpsbtAAfrIrwgB24597C9nbNJYVmtYz5cCFoFqQ1a2UxzquIi1sB60zIK_gAXRvpSApHzHrgn03GZ6vrW8F_9ZG5VbxpO5Nin4QUbgFmCtVrUV6SNywJ63E96kY5Iw5YJdRm0cIAqmq9Mmm_AHqWk8taeFhw_N713apkDXi2rS44fRVUmKSZdwLA3n8Mo6lPDJ7dDrHd4cdgQ7EubsASMdPzm2HabZvR1CnrRwRHfhX4rgUKauKE2c1KmizGcR23ZxCR5Imy_ZE4QWPXyeh9VtCBC75D4J1drOBDJt7EQ1feEKvDDzrUUUnRk60d1VwUFM2teGbat_GX6kvpdWfv8ha8lgpNU0XIII637xALxgc_xRCFapPaF7jZ5Y3dfTESYb-6qSljvTe2aE1mLK15FI42BEWwO5gOJVQHwUV1Zoj1-c8uFt-4BW9ZfZyfn=s816-no)

**Эквивалентные классы (equivalent classes)**

Это суперполезная вещь, которой мы немедленно дадим определение: эквивалентный класс — это одно или больше значений ввода, к которым ПО применяет одинаковую логику.

Предположим, что наш книготорговый веб-сайт запускает новую кампанию "Больше тратишь — больше скидка". Вот табличка из спека.

| Потраченная сумма, руб. | Скидка, % |
|-|-|
| 200 — 500 | 2 |
| 500 — 1000 | 3 |
| 1000 — 5000 | 4 |
| 5000 и более | 5 |

Мы, конечно, сразу увидели 3 бага спека:

Баг1:
Непонятно, по какой ставке рассчитывается скидка, если потрачены следующие суммы: ровно 500 руб., ровно 1000 руб., ровно 5000 руб., так как каждая из этих сумм находится не в одной, а в двух корзинах со скидками.

Баг 2:
Что означает "Потраченная сумма"? Это количество дензнаков, выплаченных только за книги, или полная сумма к оплате, включая оплату книг и расходы на доставку?

Баг 3:
Для полноты картины нужно дописать эквивалентный класс от 0 до 199,99, на значения которого никакая скидка не распространяется.

Что делаем? Правильно: идем к продюсеру. Извещаем о баге программиста. "Размораживаем" спек. Вносим в него изменения.

Вот перед нами уже отредактированная табличка:

| Стоимость купленных книг, руб. | Скидка, % |
|-|-|
| 0—199,99 | 0 |
| 200,00 — 499,99 | 2 |
| 500,00 — 999,99 | 3 |
| 1000,00 — 4999,99 | 4 |
| 5000,00 и более | 5 |

У нас получилось 5 эквивалентных классов:

| Класс | Стоимость |
|-|-|
| Класс 1: | 0—199,99 |
| Класс 2: | 200,00 — 499,99 |
| Класс 3: | 500,00 — 999,99 |
| Класс 4: | 1000,00 — 4999,99 |
| Класс 5: | 5000,00 и более |

Каждое значение внутри каждого класса является эквивалентным всем другим значениям этого класса. Почему? Потому что **ко всем значениям класса должна применяться одинаковая логика кода**. Например, при стоимости купленных книг и 1215,11 руб., и 1745,45 руб., и 2000 руб. (класс 4) полагается скидка 4%.

Составными частями класса являются:
1. Значение или корзина значений ввода (например, от500,00 до 999,99) и
2. Логика для вывода, т.е. ожидаемого результата (скидка 3% в случае с классом 3).

**Польза раскладывания значений ввода на эквивалентные классы состоит в том, что мы отсеиваем огромное количество значений ввода, использовать которые для тестирования просто** бессмысленно.

### "Тестирование программного обеспечения. Базовый курс", Святослав Куликов <a name="kulikov"></a>

Версия книги 1.2.1 от 02.08.2017, EPAM Systems. 231-236 страницы:

...

04.09.2016. Перейти на [Главную страницу](./)
